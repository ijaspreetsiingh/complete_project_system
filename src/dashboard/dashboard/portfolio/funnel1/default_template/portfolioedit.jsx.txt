// import React, { useEffect, useState, useCallback } from 'react';
// import { useSelector, useDispatch } from 'react-redux';
// import StudioEditor from "@grapesjs/studio-sdk/react";
// import "@grapesjs/studio-sdk/style";
// import { useParams, useNavigate } from 'react-router-dom';
// import { FaSync, FaDownload, FaArrowLeft, FaMagic, FaFileAlt, FaSave, FaFileExport } from 'react-icons/fa';
// import axios from "axios";

// import { updateProjectData, setSelectedTemplateForStage, updateStageBasicInfo } from '../../../../redux/funnel.jsx';
// import { templates } from './df_temp.jsx';
// import addLandingPageComponents from './function.jsx';
// import "./old.css";

// // GrapesJS Plugins
// import gjsPresetWebpage from "grapesjs-preset-webpage";
// import gjsForms from "grapesjs-plugin-forms";
// import gjsCountdown from "grapesjs-component-countdown";
// import gjsTabs from "grapesjs-tabs";
// import gjsCustomCode from "grapesjs-custom-code";
// import gjsTooltip from "grapesjs-tooltip";
// import gjsTyped from "grapesjs-typed";
// import gjsNavbar from "grapesjs-navbar";
// import gjsBlocksBasic from "grapesjs-blocks-basic";

// //** Template Selector Component **//
// const StageTemplateSelector = ({ stageType, selectedKey, onSelect }) => {
//     const templateSet = {
//         'welcome-page': templates.welcomeTemplates,
//         'vsl-page': templates.vslTemplates,
//         'thankyou-page': templates.thankyouTemplates,
//         'whatsapp-page': templates.whatsappTemplates,
//         'product-offer': templates.productOfferTemplates,
//         'custom-page': templates.miscTemplates,
//         'appointment-page': templates.appointmentTemplates,
//         'payment-page': templates.paymentTemplates,
//     }[stageType];

//     if (!templateSet || Object.keys(templateSet).length === 0) {
//         return (
//             <div className="no-templates-message">
//                 <p>No templates available for this stage type.</p>
//             </div>
//         );
//     }

//     return (
//         <div className="template-selector-container">
//             <h3 className="template-selector-title">Select a Template</h3>
//             <div className="template-grid">
//                 {Object.entries(templateSet).map(([key, template]) => (
//                     <div
//                         key={key}
//                         className={`template-card ${selectedKey === key ? 'selected' : ''}`}
//                         onClick={() => onSelect(key)}
//                     >
//                         <div className="template-thumbnail">
//                             <img
//                                 src={template.thumbnail}
//                                 alt={template.name}
//                                 onError={(e) => {
//                                     e.target.onerror = null;
//                                     e.target.src = 'https://placehold.co/400x300/ccc/ffffff?text=No+Image';
//                                 }}
//                             />
//                         </div>
//                         <div className="template-info">
//                             <h4>{template.name}</h4>
//                             <p>{template.description}</p>
//                         </div>
//                     </div>
//                 ))}
//             </div>
//         </div>
//     );
// };

// //** AI Generative Popup Component **//
// const AIGenerativePopup = ({ onClose, onSubmit, isLoading }) => {
//     const [description, setDescription] = useState('');

//     const handleSubmit = () => {
//         if (!description.trim()) {
//             alert('Please provide a description for the content you want to generate.');
//             return;
//         }
//         onSubmit({ description });
//     };

//     return (
//         <div className="ai-popup-content">
//             <h3>AI Content Generation</h3>
//             <p>Describe the changes you want to make to the content:</p>

//             <div className="description-section">
//                 <label>Describe what you want:</label>
//                 <textarea
//                     value={description}
//                     onChange={(e) => setDescription(e.target.value)}
//                     placeholder="e.g., 'Make the headline more exciting and shorten the paragraph about benefits.'"
//                     rows={4}
//                 />
//             </div>

//             <div className="ai-popup-buttons">
//                 <button onClick={onClose} className="ai-cancel-btn cancel" disabled={isLoading}>
//                     Cancel
//                 </button>
//                 <button
//                     onClick={handleSubmit}
//                     className="ai-submit-btn upload"
//                     disabled={isLoading || !description.trim()}
//                 >
//                     {isLoading ? 'Generating...' : 'Update Content'}
//                 </button>
//             </div>
//         </div>
//     );
// };

// //** Main Editor Component **//
// const PortfolioEdit = () => {
//     const dispatch = useDispatch();
//     const navigate = useNavigate();
//     const { slug, stageId } = useParams();

//     const { contentData, stages, apiStatus } = useSelector((state) => state.funnel);
//     const [editorInstance, setEditorInstance] = useState(null);
//     const [showTemplateSelector, setShowTemplateSelector] = useState(false);
//     const [showAIPopup, setShowAIPopup] = useState(false);
//     const [isAILoading, setIsAILoading] = useState(false);
//     const [currentStage, setCurrentStage] = useState(null);
//     const [forceRefreshKey, setForceRefreshKey] = useState(0);
//     const [assets, setAssets] = useState([]);

//     // Get the current stage data
//     useEffect(() => {
//         if (stages && stageId) {
//             const stage = stages.find(s => s.id === stageId);
//             if (stage) {
//                 setCurrentStage(stage);
//             }
//         }
//     }, [stages, stageId]);

//     const uploadFiles = async files => {
//         const fd = new FormData();
//         files.forEach(f => fd.append('assets', f));
//         const { data } = await axios.post('http://localhost:5000/api/assets', fd);
//         return data;
//     };

//     // Fetch initial assets from the backend when the component mounts
//     useEffect(() => {
//         const fetchInitialAssets = async () => {
//             try {
//                 const response = await fetch('http://localhost:5000/api/assets');
//                 if (!response.ok) {
//                     throw new Error(`Failed to fetch assets: ${response.statusText}`);
//                 }
//                 const result = await response.json();
//                 console.log("âœ… [Frontend] Initial assets loaded from backend:", result.data);
//                 setAssets(result.data || []);
//             } catch (error) {
//                 console.error("âŒ [Frontend] Error fetching initial assets:", error);
//                 setAssets([]);
//             }
//         };
//         fetchInitialAssets();
//     }, []);

//     const onEditorReady = useCallback((editor) => {
//         window.editor = editor;
//         setEditorInstance(editor);
//         addLandingPageComponents(editor);
//         const pagesEl = document.querySelector("#pages");
//         if (pagesEl) {
//             editor.Pages.__appendTo({ el: pagesEl });
//         }
//         setTimeout(() => {
//             const pageToSelect = editor.Pages.get(stageId);
//             if (pageToSelect) {
//                 editor.Pages.select(pageToSelect);
//             } else if (editor.Pages.getAll().length > 0) {
//                 editor.Pages.select(editor.Pages.getAll()[0]);
//             }
//         }, 500);
//     }, [stageId]);

//     useEffect(() => {
//         return () => {
//             if (editorInstance) {
//                 editorInstance.destroy();
//                 setEditorInstance(null);
//                 delete window.editor;
//             }
//         };
//     }, [editorInstance]);

//     const generateInitialProject = useCallback(() => {
//         console.log("[Frontend] Generating initial project structure for GrapesJS...");
//         const savedProjectData = contentData.projectData;
//         const hasSavedPages = savedProjectData && savedProjectData.pages && Array.isArray(savedProjectData.pages) && savedProjectData.pages.length > 0;
    
//         const createPageFromTemplate = (stage) => {
//             const isCustom = stage.type === 'custom-page';
//             const config = isCustom
//                 ? contentData.customStagesConfig?.[stage.id]
//                 : contentData.stagesConfig?.[stage.type];
//             const templateSet = {
//                 'welcome-page': templates.welcomeTemplates, 'vsl-page': templates.vslTemplates,
//                 'thankyou-page': templates.thankyouTemplates, 'whatsapp-page': templates.whatsappTemplates,
//                 'product-offer': templates.productOfferTemplates, 'custom-page': templates.miscTemplates,
//                 'appointment-page': templates.appointmentTemplates, 'payment-page': templates.paymentTemplates,
//             }[stage.type];
//             const templateKey = config?.selectedTemplateKey;
//             let template = (templateKey && templateSet && templateSet[templateKey]) 
//                             ? templateSet[templateKey] 
//                             : (templateSet ? Object.values(templateSet)[0] : null);
    
//             if (!template) {
//                  return {
//                     id: stage.id,
//                     name: stage.name,
//                     component: `<h1>${stage.name}</h1><p>Template not configured for this stage type.</p>`,
//                     styles: '', script: '',
//                     basicInfo: config?.basicInfo || {}
//                 };
//             }
    
//             return {
//                 id: stage.id,
//                 name: stage.name,
//                 component: template.html || `<h1>${stage.name}</h1><p>Template content not found.</p>`,
//                 styles: template.css || '',
//                 script: template.js || '',
//                 basicInfo: config?.basicInfo || {}
//             };
//         };
    
//         let pages;
//         let globalCss = '';
    
//         if (hasSavedPages) {
//             console.log("[Frontend] Loading project from saved Redux state (projectData).");
//             globalCss = savedProjectData.globalCss || '';
//             pages = stages.map(stage => {
//                 const savedPage = savedProjectData.pages.find(p => p.pageId === stage.id);
//                 if (savedPage) {
//                     console.log(`[Frontend] Found saved data for stage: ${stage.id}`);
//                     return {
//                         id: stage.id,
//                         name: savedPage.name || stage.name,
//                         component: savedPage.html || `<h1>${stage.name}</h1><p>Saved content loaded.</p>`,
//                         script: savedPage.js || '',
//                         basicInfo: savedPage.basicInfo || {}
//                     };
//                 }
//                 console.log(`[Frontend] No saved data for stage: ${stage.id}. Creating from template.`);
//                 return createPageFromTemplate(stage);
//             });
//         } else {
//             console.log("[Frontend] No saved projectData found. Initializing all pages from templates.");
//             pages = stages.map(stage => createPageFromTemplate(stage));
//         }
    
//         const stageIndex = pages.findIndex(p => p.id === stageId);
//         if (stageIndex > 0) {
//             const [selectedPage] = pages.splice(stageIndex, 1);
//             pages.unshift(selectedPage);
//         }
        
//         console.log("[Frontend] Final project object for GrapesJS:", { pages, css: globalCss });
//         return { pages, css: globalCss };
//     }, [stages, contentData, stageId]);

//     const applyDataToPage = (page, { html, css, js, basicInfo }) => {
//         if (!editorInstance || !page) return;
//         if (html !== undefined) { page.set('component', ''); page.set('component', html); }
//         if (css !== undefined) { editorInstance.Css.clear(); editorInstance.Css.addRules(css); }
//         if (js !== undefined) { page.set('script', js); }
//         if (basicInfo) { page.set('basicInfo', basicInfo); }
//         editorInstance.Pages.select(page);
//         editorInstance.trigger('change:canvas');
//     };

//     const extractContentForAI = (editor) => {
//         const content = [];
//         const page = editor.Pages.getSelected();
//         if (!page) return content;
//         const walkComponents = (component) => {
//             if (!component || !component.view || !component.view.el) return;
//             if (component.is('text') && component.toHTML().trim().length > 0) {
//                 content.push({ id: component.cid, type: 'text', content: component.toHTML() });
//             } else if (component.is('image')) {
//                 content.push({ id: component.cid, type: 'image', src: component.get('src') });
//             }
//             component.components().forEach(walkComponents);
//         };
//         walkComponents(page.getMainComponent());
//         return content;
//     };

//     const applyAIUpdates = (editor, updatedData) => {
//         if (!editor || !updatedData) return;
//         const currentPage = editor.Pages.getSelected();
//         if (!currentPage) return;

//         updatedData.forEach(item => {
//             const component = currentPage.getMainComponent().find(`#${item.id}`)[0];
//             if (component) {
//                 if (item.type === 'text' && item.content !== undefined) {
//                     component.components(item.content);
//                 } else if (item.type === 'image' && item.src !== undefined) {
//                     component.set('src', item.src);
//                 }
//             } else {
//                 console.warn(`[Frontend] AI Update: Component with ID ${item.id} not found.`);
//             }
//         });
//         editor.trigger('change:canvas');
//     };

//     const handleAssetUpload = async (files, onResponse) => {
//         const formData = new FormData();
//         for (let i = 0; i < files.length; i++) {
//             formData.append('assets', files[i]);
//         }
//         console.log("ðŸš€ [Frontend] Uploading files to backend...", files);
//         try {
//             const response = await fetch('http://localhost:5000/api/assets', {
//                 method: 'POST',
//                 body: formData,
//             });
//             if (!response.ok) {
//                 const errData = await response.json();
//                 throw new Error(errData.error || 'Upload failed');
//             }
//             const result = await response.json();
//             console.log('âœ… [Frontend] Files uploaded successfully. Backend response:', result);
//             onResponse(result.data);
//             setAssets(prevAssets => [...result.data, ...prevAssets]);
//         } catch (error) {
//             console.error('âŒ [Frontend] Upload error:', error);
//             alert(`Failed to upload files: ${error.message}`);
//             onResponse([]);
//         }
//     };

//     const handleSave = async (saveType) => {
//         if (!editorInstance) {
//             alert("Editor is not ready.");
//             return;
//         }
    
//         const editor = editorInstance;
//         const globalCss = editor.getCss();
    
//         const extractAssetsFromHtml = (html) => {
//             const parser = new DOMParser();
//             const doc = parser.parseFromString(html, 'text/html');
//             const images = Array.from(doc.querySelectorAll('img')).map(img => img.src);
//             const videos = Array.from(doc.querySelectorAll('video source')).map(source => source.src);
//             return [...new Set([...images, ...videos])].filter(url => url.startsWith('http'));
//         };
    
//         if (saveType === 'single') {
//             const currentPage = editor.Pages.getSelected();
//             if (!currentPage) {
//                 alert("No page is selected to save.");
//                 return;
//             }
    
//             const pageHtml = currentPage.getMainComponent().toHTML();
//             const singlePagePayload = {
//                 pageId: currentPage.id,
//                 name: currentPage.get('name'),
//                 html: pageHtml,
//                 css: globalCss,
//                 js: currentPage.get('script') || '',
//                 assets: extractAssetsFromHtml(pageHtml),
//                 basicInfo: currentPage.get('basicInfo') || {},
//             };
    
//             console.log(`ðŸš€ [Frontend] Saving single page data. Sending to backend:`, singlePagePayload);
    
//             try {
//                 const response = await fetch('http://localhost:5000/api/pages/save-single', {
//                     method: 'POST',
//                     headers: { 'Content-Type': 'application/json' },
//                     body: JSON.stringify(singlePagePayload)
//                 });
    
//                 if (!response.ok) {
//                     throw new Error(`Server responded with status: ${response.status}`);
//                 }
    
//                 const result = await response.json();
//                 console.log("âœ… [Frontend] Save successful. Backend response:", result);
//                 alert(result.message);
    
//                 const currentProjectData = contentData.projectData || { pages: [] };
//                 const otherPages = currentProjectData.pages.filter(p => p.pageId !== singlePagePayload.pageId);
//                 const newProjectData = {
//                     pages: [...otherPages, singlePagePayload],
//                     globalCss: globalCss
//                 };
//                 dispatch(updateProjectData(newProjectData));
    
//             } catch (error) {
//                 console.error('âŒ [Frontend] Save error:', error);
//                 alert(`Failed to save data: ${error.message}`);
//             }
    
//         } else { // 'all'
//             const allPagesData = editor.Pages.getAll().map(page => {
//                 const pageHtml = page.getMainComponent().toHTML();
//                 return {
//                     pageId: page.id,
//                     name: page.get('name'),
//                     html: pageHtml,
//                     js: page.get('script') || '',
//                     assets: extractAssetsFromHtml(pageHtml),
//                     basicInfo: page.get('basicInfo') || {},
//                 };
//             });
    
//             const allPagesPayload = {
//                 pages: allPagesData,
//                 globalCss: globalCss
//             };
    
//             console.log(`ðŸš€ [Frontend] Saving all pages data. Sending to backend:`, allPagesPayload);
    
//             try {
//                 const response = await fetch('http://localhost:5000/api/pages/save-all', {
//                     method: 'POST',
//                     headers: { 'Content-Type': 'application/json' },
//                     body: JSON.stringify(allPagesPayload)
//                 });
    
//                 if (!response.ok) {
//                     throw new Error(`Server responded with status: ${response.status}`);
//                 }
    
//                 const result = await response.json();
//                 console.log("âœ… [Frontend] Save successful. Backend response:", result);
//                 alert(result.message);
//                 dispatch(updateProjectData(allPagesPayload));
    
//             } catch (error) {
//                 console.error('âŒ [Frontend] Save error:', error);
//                 alert(`Failed to save data: ${error.message}`);
//             }
//         }
//     };

//     const handleDownloadProject = () => {
//         if (!editorInstance) { alert("Editor is not ready."); return; }
//         const editor = editorInstance;
//         const currentPage = editor.Pages.getSelected();
//         if (!currentPage) { alert("No page is selected to download."); return; }
//         const pageName = currentPage.get('name') || `page-${currentPage.cid}`;
//         const fullCode = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${pageName}</title><style>${editor.getCss()}</style></head><body>${currentPage.getMainComponent().toHTML()}<script>${currentPage.get('script') || ''}</script></body></html>`;
//         const blob = new Blob([fullCode], { type: 'text/html' });
//         const a = document.createElement('a');
//         a.href = URL.createObjectURL(blob);
//         a.download = `${pageName.toLowerCase().replace(/\s+/g, '-')}.html`;
//         a.click();
//         URL.revokeObjectURL(a.href);
//     };

//     const handleAISubmit = async ({ description }) => {
//         if (!editorInstance) { alert("Editor not available."); return; }
//         const page = editorInstance.Pages.getSelected();
//         if (!page) { alert("Please select a page first."); return; }

//         setIsAILoading(true);
//         const contentToUpdate = extractContentForAI(editorInstance);
//         if (contentToUpdate.length === 0) {
//             alert("No text or image content found on this page to update.");
//             setIsAILoading(false);
//             return;
//         }

//         const requestBody = { description, contentToUpdate, pageInfo: { id: page.id, name: page.get('name') } };
//         console.log("ðŸš€ [Frontend] Sending content to AI API:", requestBody);

//         try {
//             const response = await fetch('http://localhost:5000/api/ai/generate-content', {
//                 method: 'POST',
//                 headers: { 'Content-Type': 'application/json' },
//                 body: JSON.stringify(requestBody)
//             });

//             if (!response.ok) {
//                 throw new Error(`Server responded with status: ${response.status}`);
//             }

//             const aiResponse = await response.json();
//             console.log("âœ… [Frontend] Received AI response:", aiResponse);

//             applyAIUpdates(editorInstance, aiResponse.updatedContent);
//             alert("Content updated successfully by AI!");

//         } catch (error) {
//             console.error('âŒ [Frontend] AI Generation Error:', error);
//             alert(`Failed to update content: ${error.message}`);
//         } finally {
//             setIsAILoading(false);
//             setShowAIPopup(false);
//         }
//     };

//     const handleTemplateSelect = (templateKey) => {
//         if (!currentStage || !editorInstance) return;
//         const templateSet = {
//             'welcome-page': templates.welcomeTemplates, 'vsl-page': templates.vslTemplates,
//             'thankyou-page': templates.thankyouTemplates, 'whatsapp-page': templates.whatsappTemplates,
//             'product-offer': templates.productOfferTemplates, 'custom-page': templates.miscTemplates,
//             'appointment-page': templates.appointmentTemplates, 'payment-page': templates.paymentTemplates,
//         }[currentStage.type];
//         const template = templateSet?.[templateKey];
//         if (!template) { console.error('Template not found:', templateKey); return; }
//         dispatch(setSelectedTemplateForStage({ stageId: currentStage.id, templateKey, stageType: currentStage.type }));
//         const page = editorInstance.Pages.get(currentStage.id);
//         if (page) {
//             applyDataToPage(page, { html: template.html, css: template.css, js: template.js, basicInfo: template.basicInfo || {} });
//         }
//         setShowTemplateSelector(false);
//     };

//     const openTemplateSelector = (stage) => { setCurrentStage(stage); setShowTemplateSelector(true); };
//     const getSelectedTemplateKey = () => {
//         if (!currentStage) return null;
//         const config = currentStage.type === 'custom-page'
//             ? contentData.customStagesConfig?.[currentStage.id]
//             : contentData.stagesConfig?.[currentStage.type];
//         return config?.selectedTemplateKey;
//     };
//     const forceTemplateRefresh = () => {
//         if (window.confirm("Are you sure? This will reload all pages from their initial templates and discard unsaved changes.")) {
//             setForceRefreshKey(prev => prev + 1);
//         }
//     };

//     const editorKey = `funnel-editor-${slug}-${forceRefreshKey}`;

//     return (
//         <div className="portfolio-edit-container">
//             {showTemplateSelector && currentStage && (
//                 <div className="modal-overlay">
//                     <div className="modal-content">
//                         <button className="modal-close-btn" onClick={() => setShowTemplateSelector(false)}>Ã—</button>
//                         <StageTemplateSelector
//                             stageType={currentStage.type}
//                             selectedKey={getSelectedTemplateKey()}
//                             onSelect={handleTemplateSelect}
//                         />
//                     </div>
//                 </div>
//             )}

//             {showAIPopup && (
//                 <div className="modal-overlay">
//                     <div className="modal-content ai-modal-content">
//                         <AIGenerativePopup
//                             isLoading={isAILoading}
//                             onClose={() => setShowAIPopup(false)}
//                             onSubmit={handleAISubmit}
//                         />
//                     </div>
//                 </div>
//             )}

//             <div className="action-buttons">
//                 <button onClick={() => handleSave('single')} className="action-button save-button">
//                     <FaSave /> <span>Save Page</span>
//                 </button>
//                 <button onClick={() => handleSave('all')} className="action-button save-all-button">
//                     <FaFileExport /> <span>Save All</span>
//                 </button>
//                 <button onClick={() => setShowAIPopup(true)} className="action-button ai-generate-button">
//                     <FaMagic /> <span>AI Content</span>
//                 </button>
//                 <button onClick={forceTemplateRefresh} className="action-button refresh-button">
//                     <FaSync /> <span>Refresh</span>
//                 </button>
//                 <button onClick={handleDownloadProject} className="action-button download-button">
//                     <FaDownload /> <span>Download</span>
//                 </button>
//                 <button onClick={() => navigate(`/dashboard/Funnel_settings/${slug}`)} className="action-button back-button">
//                     <FaArrowLeft /> <span>Back</span>
//                 </button>
//             </div>

//             <div className="editor-main-area">
//                 <div id="pages" className="pages-container" />
//                 <StudioEditor
//                     key={editorKey}
//                     onEditor={onEditorReady}
//                     style={{ width: "100%", height: "100%" }}
//                     options={{
//                         storage: {
//                             type: "self",
//                             onSave: async ({ project }) => console.log("[Frontend] Project auto-synced (GrapesJS internal).", project),
//                             onLoad: () => ({ project: generateInitialProject() }),
//                         },
//                         assetManager: {
//                             assets,
//                             upload: 'http://localhost:5000/api/assets',
//                             uploadName: 'assets',
//                             multiUpload: true,
//                             customUpload: async (files, onComplete, onError) => {
//                                 try {
//                                     const uploaded = await uploadFiles(files);
//                                     onComplete(uploaded);
//                                     setAssets(prev => [...uploaded, ...prev]);
//                                 } catch (err) {
//                                     console.error(err);
//                                     onError(err.message);
//                                 }
//                             },
//                         },
//                         plugins: [
//                             gjsForms, gjsCountdown, gjsTabs, gjsCustomCode,
//                             gjsTooltip, gjsTyped, gjsNavbar, gjsBlocksBasic,
//                         ],
//                     }}
//                 />
//             </div>

//             <style jsx>{`
//                 /* --- Main Layout --- */
//                 .portfolio-edit-container {
//                     display: flex;
//                     height: 100vh; 
//                     width: 100vw;
//                     position: relative; 
//                     overflow: hidden;
//                     font-family: 'Segoe UI', Tahoma, sans-serif;
//                     background-color: #f0f2f5;
//                 }
//                 .editor-main-area {
//                     flex-grow: 1;
//                     position: relative;
//                     height: 100%;
//                 }
//                 .pages-container {
//                     position: absolute; 
//                     top: 15px; 
//                     left: 15px;
//                     z-index: 1000; 
//                     background: rgba(30, 30, 30, 0.9);
//                     color: white;
//                     padding: 8px; 
//                     border-radius: 8px;
//                     box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
//                 }

//                 /* --- Action Buttons --- */
//                 .action-buttons {
//                     position: fixed; 
//                     bottom: 20px; 
//                     right: 20px;
//                     z-index: 1001; 
//                     display: flex;
//                     flex-direction: column; 
//                     gap: 12px;
//                 }
//                 .action-button {
//                     padding: 12px 18px; 
//                     border: none; 
//                     border-radius: 8px;
//                     font-weight: 600; 
//                     cursor: pointer;
//                     transition: all 0.2s ease;
//                     box-shadow: 0 2px 5px rgba(0,0,0,0.1);
//                     display: flex; 
//                     align-items: center; 
//                     gap: 10px; 
//                     font-size: 14px;
//                 }
//                 .action-button:hover {
//                     transform: translateY(-3px);
//                     box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
//                 }
//                 .action-button > svg { 
//                     font-size: 1.1rem; 
//                 }
//                 .save-button { background-color: #3498db; color: white; }
//                 .save-all-button { background-color: #16a085; color: white; }
//                 .ai-generate-button { background-color: #8e44ad; color: white; }
//                 .refresh-button { background-color: #f39c12; color: white; }
//                 .download-button { background-color: #27ae60; color: white; }
//                 .back-button { background-color: #c0392b; color: white; }

//                 /* --- Modal Styles --- */
//                 .modal-overlay {
//                     position: fixed; top: 0; left: 0;
//                     width: 100%; height: 100%;
//                     background-color: rgba(0, 0, 0, 0.6);
//                     display: flex; justify-content: center; align-items: center;
//                     z-index: 2000;
//                 }
//                 .modal-content {
//                     background: white; padding: 25px; border-radius: 10px;
//                     box-shadow: 0 5px 15px rgba(0,0,0,0.3);
//                     max-width: 90vw; max-height: 90vh;
//                     overflow-y: auto; position: relative;
//                 }
//                 .modal-close-btn {
//                     position: absolute; top: 10px; right: 15px;
//                     background: transparent; border: none;
//                     font-size: 24px; cursor: pointer; color: #888;
//                 }
//                     .cancel{
//                         background-color: #4a5568 !important;
//     color: #e0e6ed;
//     border: 1px solid #5a6b7d;
//     padding: 12px 25px;
//     border-radius: 10px;
//     font-size: 15px;
//     font-weight: 700;
//     cursor: pointer;
//     transition: all 0.3s ease-in-out, transform 0.2s ease-out;
//     letter-spacing: 0.3px;
//     box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
//                     }
//                 .ai-modal-content { max-width: 550px; }

//                 /* --- AI Popup Specific Styles --- */
//                 .ai-popup-content h3 { margin-top: 0; color: #333; }
//                 .ai-popup-content p { color: #555; margin-bottom: 20px; }
//                 .description-section { margin-top: 15px; }
//                 .description-section label { display: block;color:black; margin-bottom: 8px; font-weight: 500; }
//                 .description-section textarea { width: 100%; color:black; padding: 10px; border-radius: 5px; border: 1px solid #ccc; resize: vertical; box-sizing: border-box; }
//                 .ai-popup-buttons { display: flex; justify-content: flex-end; gap: 10px; margin-top: 25px; }
//                 .ai-popup-buttons button { padding: 10px 20px; border-radius: 5px; border: none; font-weight: 500; cursor: pointer; }
//                 .ai-cancel-btn { background-color: #eee; }
//                 .ai-submit-btn { background-color: #4f46e5; color: white; }
//                 .ai-submit-btn:disabled { background-color: #ccc; cursor: not-allowed; }

//                 /* --- Template Selector Styles --- */
//                 .template-selector-container { width: 90vw; max-width: 1200px; }
//                 .template-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; }
//                 .template-card { border: 2px solid transparent; border-radius: 8px; overflow: hidden; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
//                 .template-card:hover { transform: translateY(-5px); box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
//                 .template-card.selected { border-color: #3498db; box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }
//                 .template-thumbnail img { width: 100%; height: auto; display: block; background-color: #eee; }
//                 .template-info { padding: 15px; }
//                 .template-info h4 { margin: 0 0 8px 0; font-size: 16px; }
//                 .template-info p { margin: 0; font-size: 14px; color: #666; }
//                 .main-content.fixed-sidebar { margin-left:0px; }
//             `}</style>
//         </div>
//     );
// };

// export default PortfolioEdit;





























// import React, { useEffect, useState, useCallback } from 'react';
// import { useSelector, useDispatch } from 'react-redux';
// import StudioEditor from "@grapesjs/studio-sdk/react";
// import "@grapesjs/studio-sdk/style";
// import { useParams, useNavigate } from 'react-router-dom';
// import { FaSync, FaDownload, FaArrowLeft, FaMagic, FaFileAlt, FaSave, FaFileExport } from 'react-icons/fa';

// import { updateProjectData, setSelectedTemplateForStage, updateStageBasicInfo } from '../../../../redux/funnel.jsx'; 
// import { templates } from './df_temp.jsx';
// import addLandingPageComponents from './function.jsx';
// import "./old.css";

// // GrapesJS Plugins
// import gjsPresetWebpage from "grapesjs-preset-webpage";
// import gjsForms from "grapesjs-plugin-forms";
// import gjsCountdown from "grapesjs-component-countdown";
// import gjsTabs from "grapesjs-tabs";
// import gjsCustomCode from "grapesjs-custom-code";
// import gjsTooltip from "grapesjs-tooltip";
// import gjsTyped from "grapesjs-typed";
// import gjsNavbar from "grapesjs-navbar";
// import gjsBlocksBasic from "grapesjs-blocks-basic";

// //** Template Selector Component **//
// const StageTemplateSelector = ({ stageType, selectedKey, onSelect }) => {
//     const templateSet = {
//         'welcome-page': templates.welcomeTemplates,
//         'vsl-page': templates.vslTemplates,
//         'thankyou-page': templates.thankyouTemplates,
//         'whatsapp-page': templates.whatsappTemplates,
//         'product-offer': templates.productOfferTemplates,
//         'custom-page': templates.miscTemplates,
//         'appointment-page': templates.appointmentTemplates,
//         'payment-page': templates.paymentTemplates,
//     }[stageType];

//     if (!templateSet || Object.keys(templateSet).length === 0) {
//         return (
//             <div className="no-templates-message">
//                 <p>No templates available for this stage type.</p>
//             </div>
//         );
//     }

//     return (
//         <div className="template-selector-container">
//             <h3 className="template-selector-title">Select a Template</h3>
//             <div className="template-grid">
//                 {Object.entries(templateSet).map(([key, template]) => (
//                     <div
//                         key={key}
//                         className={`template-card ${selectedKey === key ? 'selected' : ''}`}
//                         onClick={() => onSelect(key)}
//                     >
//                         <div className="template-thumbnail">
//                             <img
//                                 src={template.thumbnail}
//                                 alt={template.name}
//                                 onError={(e) => {
//                                     e.target.onerror = null;
//                                     e.target.src = 'https://placehold.co/400x300/ccc/ffffff?text=No+Image';
//                                 }}
//                             />
//                         </div>
//                         <div className="template-info">
//                             <h4>{template.name}</h4>
//                             <p>{template.description}</p>
//                         </div>
//                     </div>
//                 ))}
//             </div>
//         </div>
//     );
// };


// //** AI Generative Popup Component **//
// const AIGenerativePopup = ({ onClose, onSubmit, isLoading }) => {
//     const [description, setDescription] = useState('');

//     const handleSubmit = () => {
//         if (!description.trim()) {
//             alert('Please provide a description for the content you want to generate.');
//             return;
//         }
//         onSubmit({ action: 'content', description });
//     };

//     return (
//         <div className="ai-popup-content">
//             <h3>AI Content Generation</h3>
//             <p>Describe the changes you want to make to the content:</p>

//             <div className="description-section">
//                 <label>Describe what you want:</label>
//                 <textarea
//                     value={description}
//                     onChange={(e) => setDescription(e.target.value)}
//                     placeholder="e.g., 'Make the headline more exciting and shorten the paragraph about benefits.'"
//                     rows={4}
//                 />
//             </div>

//             <div className="ai-popup-buttons">
//                 <button onClick={onClose} className="ai-cancel-btn" disabled={isLoading}>
//                     Cancel
//                 </button>
//                 <button 
//                     onClick={handleSubmit} 
//                     className="ai-submit-btn"
//                     disabled={isLoading || !description.trim()}
//                 >
//                     {isLoading ? 'Generating...' : 'Update Content'}
//                 </button>
//             </div>
//         </div>
//     );
// };


// //** Main Editor Component **//
// const PortfolioEdit = () => {
//     const dispatch = useDispatch();
//     const navigate = useNavigate();
//     const { slug, stageId } = useParams();

//     const { contentData, stages } = useSelector((state) => state.funnel);
//     const [editorInstance, setEditorInstance] = useState(null);
//     const [showTemplateSelector, setShowTemplateSelector] = useState(false);
//     const [showAIPopup, setShowAIPopup] = useState(false);
//     const [isAILoading, setIsAILoading] = useState(false);
//     const [currentStage, setCurrentStage] = useState(null);
//     const [forceRefreshKey, setForceRefreshKey] = useState(0);

//     const onEditorReady = useCallback((editor) => {
//         window.editor = editor;
//         setEditorInstance(editor);
//         addLandingPageComponents(editor);
//         editor.Pages.__appendTo({ el: "#pages" });

//         setTimeout(() => {
//             const pageToSelect = editor.Pages.get(stageId);
//             if (pageToSelect) {
//                 editor.Pages.select(pageToSelect);
//             } else if (editor.Pages.getAll().length > 0) {
//                 editor.Pages.select(editor.Pages.getAll()[0]);
//             }
//         }, 500);
//     }, [stageId]);

//     useEffect(() => {
//         return () => {
//             if (editorInstance) {
//                 editorInstance.destroy();
//                 setEditorInstance(null);
//                 delete window.editor;
//             }
//         };
//     }, [editorInstance]);

//     //** Core Data Handling Functions **//

//     const generateInitialProject = useCallback(() => {
//         console.log("Generating initial project structure...");
//         const orderedStages = stages.slice();
//         const stageIndex = orderedStages.findIndex(stage => stage.id === stageId);
//         if (stageIndex > 0) {
//             const [selectedStage] = orderedStages.splice(stageIndex, 1);
//             orderedStages.unshift(selectedStage);
//         }

//         const pages = orderedStages.map(stage => {
//             const isCustom = stage.type === 'custom-page';
//             const config = isCustom
//                 ? contentData.customStagesConfig?.[stage.id]
//                 : contentData.stagesConfig?.[stage.type];

//             const templateSet = {
//                 'welcome-page': templates.welcomeTemplates, 'vsl-page': templates.vslTemplates,
//                 'thankyou-page': templates.thankyouTemplates, 'whatsapp-page': templates.whatsappTemplates,
//                 'product-offer': templates.productOfferTemplates, 'custom-page': templates.miscTemplates,
//                 'appointment-page': templates.appointmentTemplates, 'payment-page': templates.paymentTemplates,
//             }[stage.type];

//             const templateKey = config?.selectedTemplateKey;
//             let template = templateKey && templateSet[templateKey] ? templateSet[templateKey] : Object.values(templateSet)[0];

//             return {
//                 id: stage.id, name: stage.name,
//                 component: template?.html || `<h1>${stage.name}</h1><p>Template not loaded.</p>`,
//                 styles: template?.css || '', script: template?.js || '',
//                 basicInfo: config ? config.basicInfo : {}
//             };
//         });

//         return { pages };
//     }, [stages, contentData, stageId]);

//     const applyDataToPage = (page, { html, css, js, basicInfo }) => {
//         if (!editorInstance || !page) return;
//         if (html !== undefined) { page.set('component', ''); page.set('component', html); }
//         if (css !== undefined) { editorInstance.Css.clear(); editorInstance.Css.addRules(css); }
//         if (js !== undefined) { page.set('script', js); }
//         if (basicInfo) { /* ... dispatch logic ... */ }
//         editorInstance.Pages.select(page);
//         editorInstance.trigger('change:canvas');
//     };

//     //** Function to extract content for AI **//
//     const extractContentForAI = (editor) => {
//         const content = [];
//         const page = editor.Pages.getSelected();
//         if (!page) return content;

//         const walkComponents = (component) => {
//             if (!component || !component.view || !component.view.el) return;

//             if (component.is('text')) {
//                 const textContent = component.toHTML();
//                 if (textContent && textContent.trim().length > 0) {
//                     content.push({ id: component.cid, type: 'text', content: textContent });
//                 }
//             } else if (component.is('image')) {
//                 content.push({ id: component.cid, type: 'image', src: component.get('src') });
//             }

//             component.components().forEach(walkComponents);
//         };

//         walkComponents(page.getMainComponent());
//         return content;
//     };

//     //** Function to apply AI updates **//
//     const applyAIUpdates = (editor, updatedData) => {
//         if (!editor || !updatedData) return;
//         const allComponents = editor.getComponents();
//         updatedData.forEach(item => {
//             const component = allComponents.filter(c => c.cid === item.id)[0];
//             if (component) {
//                 if (item.type === 'text' && item.content !== undefined) {
//                     component.components(item.content);
//                 } else if (item.type === 'image' && item.src !== undefined) {
//                     const currentAttributes = component.get('attributes');
//                     component.set('attributes', { ...currentAttributes, src: item.src });
//                 }
//             } else {
//                 console.warn(`AI Update: Component with ID ${item.id} not found.`);
//             }
//         });
//         editor.trigger('change:canvas');
//     };

//     //** Action Button Handlers **//
//     const handleSave = async (saveType) => {
//         if (!editorInstance) {
//             alert("Editor is not ready.");
//             return;
//         }

//         try {
//             const editor = editorInstance;

//             if (saveType === 'single') {
//                 const currentPage = editor.Pages.getSelected();
//                 if (!currentPage) {
//                     alert("No page is selected to save.");
//                     return;
//                 }

//                 const pageData = {
//                     id: currentPage.id,
//                     name: currentPage.get('name'),
//                     html: editor.getHtml(),
//                     css: editor.getCss(),
//                     js: currentPage.get('script')
//                 };

//                 console.log('Saving single page:', pageData);
//                 dispatch(updateProjectData({ 
//                     pages: [pageData],
//                     globalCss: editor.getCss()
//                 }));

//                 alert(`Page "${pageData.name}" saved successfully!`);
//             } else { // 'all'
//                 const allPagesData = editor.Pages.getAll().map(page => ({
//                     id: page.id,
//                     name: page.get('name'),
//                     html: page.getMainComponent().toHTML(),
//                     js: page.get('script')
//                 }));

//                 console.log('Saving all pages:', allPagesData);
//                 dispatch(updateProjectData({ 
//                     pages: allPagesData,
//                     globalCss: editor.getCss()
//                 }));

//                 alert(`All ${allPagesData.length} pages saved successfully!`);
//             }
//         } catch (error) {
//             console.error('Save error:', error);
//             alert('Failed to save. Please try again.');
//         }
//     };

//     const handleDownloadProject = () => {
//         if (!editorInstance) {
//             alert("Editor is not ready.");
//             return;
//         }

//         const editor = editorInstance;
//         const currentPage = editor.Pages.getSelected();

//         if (!currentPage) {
//             alert("No page is selected to download.");
//             return;
//         }

//         const pageName = currentPage.get('name') || `page-${currentPage.cid}`;
//         const pageHtml = editor.getHtml();
//         const pageCss = editor.getCss();
//         const pageJs = currentPage.get('script') || '';

//         const fullCode = `<!DOCTYPE html>
// <html lang="en">
// <head>
//     <meta charset="UTF-8">
//     <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     <title>${pageName}</title>
//     <style>${pageCss}</style>
// </head>
// <body>${pageHtml}
//     <script>${pageJs}</script>
// </body>
// </html>`;

//         const blob = new Blob([fullCode], { type: 'text/html' });
//         const url = URL.createObjectURL(blob);
//         const a = document.createElement('a');
//         a.href = url;
//         a.download = `${pageName.toLowerCase().replace(/\s+/g, '-')}.html`;
//         document.body.appendChild(a);
//         a.click();
//         document.body.removeChild(a);
//         URL.revokeObjectURL(url);
//     };

//     const handleAISubmit = async ({ description }) => {
//         if (!editorInstance) { alert("Editor not available."); return; }
//         const page = editorInstance.Pages.getSelected();
//         if (!page) { alert("Please select a page first."); return; }

//         setIsAILoading(true);
//         const contentToUpdate = extractContentForAI(editorInstance);

//         if (contentToUpdate.length === 0) {
//             alert("No text or image content found on this page to update.");
//             setIsAILoading(false);
//             return;
//         }

//         const requestBody = { description, contentToUpdate, pageInfo: { id: page.id, name: page.get('name') } };
//         console.log("--- Sending structured data to AI API ---", requestBody);

//         try {
//             // MOCK API CALL - Your backend should return an array with the same structure
//             const aiResponse = await new Promise(resolve => setTimeout(() => {
//                 const updatedContent = requestBody.contentToUpdate.map(item => {
//                     if (item.type === 'text') {
//                         return { ...item, content: `${item.content.replace(/<[^>]+>/g, '')} (Updated by AI)` };
//                     }
//                     return item;
//                 });
//                 resolve({ updatedContent });
//             }, 1500));

//             applyAIUpdates(editorInstance, aiResponse.updatedContent);
//             alert("Content updated successfully by AI!");

//         } catch (error) {
//             console.error('AI Generation Error:', error);
//             alert('Failed to update content. Please try again.');
//         } finally {
//             setIsAILoading(false);
//             setShowAIPopup(false);
//         }
//     };

//     const handleTemplateSelect = (templateKey) => {
//         if (!currentStage || !editorInstance) return;

//         const templateSet = {
//             'welcome-page': templates.welcomeTemplates,
//             'vsl-page': templates.vslTemplates,
//             'thankyou-page': templates.thankyouTemplates,
//             'whatsapp-page': templates.whatsappTemplates,
//             'product-offer': templates.productOfferTemplates,
//             'custom-page': templates.miscTemplates,
//             'appointment-page': templates.appointmentTemplates,
//             'payment-page': templates.paymentTemplates,
//         }[currentStage.type];

//         const template = templateSet?.[templateKey];
//         if (!template) {
//             console.error('Template not found:', templateKey);
//             return;
//         }

//         dispatch(setSelectedTemplateForStage({ 
//             stageId: currentStage.id, 
//             templateKey, 
//             stageType: currentStage.type 
//         }));

//         const page = editorInstance.Pages.get(currentStage.id);
//         if (page) {
//             applyDataToPage(page, {
//                 html: template.html,
//                 css: template.css,
//                 js: template.js
//             });
//         }

//         setShowTemplateSelector(false);
//     };

//     const openTemplateSelector = (stage) => { 
//         setCurrentStage(stage); 
//         setShowTemplateSelector(true); 
//     };

//     const getSelectedTemplateKey = () => {
//         if (!currentStage) return null;
//         const isCustom = currentStage.type === 'custom-page';
//         const config = isCustom
//             ? contentData.customStagesConfig?.[currentStage.id]
//             : contentData.stagesConfig?.[currentStage.type];
//         return config?.selectedTemplateKey;
//     };

//     const forceTemplateRefresh = () => {
//         if (window.confirm("Are you sure? This will reload all pages from their initial templates and discard unsaved changes.")) {
//             setForceRefreshKey(prev => prev + 1);
//         }
//     };

//     const editorKey = `funnel-editor-${slug}-${forceRefreshKey}`;

//     return (
//         <div className="portfolio-edit-container">
//             {showTemplateSelector && currentStage && (
//                 <div className="modal-overlay">
//                     <div className="modal-content">
//                         <button className="modal-close-btn" onClick={() => setShowTemplateSelector(false)}>Ã—</button>
//                         <StageTemplateSelector 
//                             stageType={currentStage.type} 
//                             selectedKey={getSelectedTemplateKey()} 
//                             onSelect={handleTemplateSelect} 
//                         />
//                     </div>
//                 </div>
//             )}

//             {showAIPopup && (
//                 <div className="modal-overlay">
//                     <div className="modal-content ai-modal-content">
//                         <AIGenerativePopup 
//                             isLoading={isAILoading} 
//                             onClose={() => setShowAIPopup(false)} 
//                             onSubmit={handleAISubmit} 
//                         />
//                     </div>
//                 </div>
//             )}

//             <div className="action-buttons">
//                 <button onClick={() => handleSave('single')} className="action-button save-button">
//                     <FaSave /> <span>Save Page</span>
//                 </button>
//                 <button onClick={() => handleSave('all')} className="action-button save-all-button">
//                     <FaFileExport /> <span>Save All</span>
//                 </button>
//                 <button onClick={() => setShowAIPopup(true)} className="action-button ai-generate-button">
//                     <FaMagic /> <span>AI Content</span>
//                 </button>
//                 <button onClick={forceTemplateRefresh} className="action-button refresh-button">
//                     <FaSync /> <span>Refresh</span>
//                 </button>
//                 <button onClick={handleDownloadProject} className="action-button download-button">
//                     <FaDownload /> <span>Download</span>
//                 </button>
//                 <button onClick={() => navigate(`/dashboard/Funnel_settings/${slug}`)} className="action-button back-button">
//                     <FaArrowLeft /> <span>Back</span>
//                 </button>
//             </div>

//             <div className="editor-main-area">
//                 <div id="pages" className="pages-container" />
//                 <StudioEditor
//                     key={editorKey}
//                     onEditor={onEditorReady}
//                     style={{
//                         width:"100%",
//                         height:"100%"
//                     }}
//                     options={{
//                         storage: {
//                             type: "self",
//                             onSave: async ({ project }) => {
//                                 dispatch(updateProjectData(project));
//                                 console.log("Project data synced to Redux.", project);
//                             },
//                             onLoad: () => ({ project: generateInitialProject() }),
//                         },
//                         plugins: [
//                             gjsForms, gjsCountdown, gjsTabs, gjsCustomCode, 
//                             gjsTooltip, gjsTyped, gjsNavbar, gjsBlocksBasic,
//                         ],
//                     }}
//                 />
//             </div>

//             <style jsx>{`
//                 /* --- Main Layout --- */
//                 .portfolio-edit-container {
//                     display: flex;
//                     height: 100vh; 
//                     width: 100vw;
//                     position: relative; 
//                     overflow: hidden;
//                     font-family: 'Segoe UI', Tahoma, sans-serif;
//                     background-color: #f0f2f5;
//                 }
//                 .editor-main-area {
//                     flex-grow: 1;
//                     position: relative;
//                     height: 100%;
//                 }
//                 .pages-container {
//                     position: absolute; 
//                     top: 15px; 
//                     left: 15px;
//                     z-index: 1000; 
//                     background: rgba(30, 30, 30, 0.9);
//                     color: white;
//                     padding: 8px; 
//                     border-radius: 8px;
//                     box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
//                 }

//                 /* --- Action Buttons --- */
//                 .action-buttons {
//                     position: fixed; 
//                     bottom: 20px; 
//                     right: 20px;
//                     z-index: 1001; 
//                     display: flex;
//                     flex-direction: column; 
//                     gap: 12px;
//                 }
//                 .action-button {
//                     padding: 12px 18px; 
//                     border: none; 
//                     border-radius: 8px;
//                     font-weight: 600; 
//                     cursor: pointer;
//                     transition: all 0.2s ease;
//                     box-shadow: 0 2px 5px rgba(0,0,0,0.1);
//                     display: flex; 
//                     align-items: center; 
//                     gap: 10px; 
//                     font-size: 14px;
//                 }
//                 .action-button:hover {
//                     transform: translateY(-3px);
//                     box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
//                 }
//                 .action-button > svg { 
//                     font-size: 1.1rem; 
//                 }
//                 .save-button { 
//                     background-color: #3498db; 
//                     color: white; 
//                 }
//                 .save-all-button { 
//                     background-color: #16a085; 
//                     color: white; 
//                 }
//                 .ai-generate-button { 
//                     background-color: #8e44ad; 
//                     color: white; 
//                 }
//                 .refresh-button { 
//                     background-color: #f39c12; 
//                     color: white; 
//                 }
//                 .download-button { 
//                     background-color: #27ae60; 
//                     color: white; 
//                 }
//                 .back-button { 
//                     background-color: #c0392b; 
//                     color: white; 
//                 }

//                 /* --- Modal Styles --- */
//                 .modal-overlay {
//                     position: fixed; 
//                     top: 0; 
//                     left: 0;
//                     width: 100%; 
//                     height: 100%;
//                     background-color: rgba(0, 0, 0, 0.6);
//                     display: flex; 
//                     justify-content: center; 
//                     align-items: center;
//                     z-index: 2000;
//                 }
//                 .modal-content {
//                     background: white; 
//                     padding: 25px; 
//                     border-radius: 10px;
//                     box-shadow: 0 5px 15px rgba(0,0,0,0.3);
//                     max-width: 90vw; 
//                     max-height: 90vh;
//                     overflow-y: auto; 
//                     position: relative;
//                 }
//                 .modal-close-btn {
//                     position: absolute; 
//                     top: 10px; 
//                     right: 15px;
//                     background: transparent; 
//                     border: none;
//                     font-size: 24px; 
//                     cursor: pointer; 
//                     color: #888;
//                 }
//                 .ai-modal-content { 
//                     max-width: 550px; 
//                 }

//                 /* --- AI Popup Specific Styles --- */
//                 .ai-popup-content h3 { 
//                     margin-top: 0; 
//                     color: #333; 
//                 }
//                 .ai-popup-content p { 
//                     color: #555; 
//                     margin-bottom: 20px; 
//                 }
//                 .description-section { 
//                     margin-top: 15px; 
//                 }
//                 .description-section label { 
//                     display: block; 
//                     margin-bottom: 8px; 
//                     font-weight: 500; 
//                 }
//                 .description-section textarea { 
//                     width: 100%; 
//                     padding: 10px; 
//                     border-radius: 5px; 
//                     border: 1px solid #ccc; 
//                     resize: vertical; 
//                     box-sizing: border-box; 
//                 }
//                 .ai-popup-buttons { 
//                     display: flex; 
//                     justify-content: flex-end; 
//                     gap: 10px; 
//                     margin-top: 25px; 
//                 }
//                 .ai-popup-buttons button { 
//                     padding: 10px 20px; 
//                     border-radius: 5px; 
//                     border: none; 
//                     font-weight: 500; 
//                     cursor: pointer; 
//                 }
//                 .ai-cancel-btn { 
//                     background-color: #eee; 
//                 }
//                 .ai-submit-btn { 
//                     background-color: #8e44ad; 
//                     color: white; 
//                 }
//                 .ai-submit-btn:disabled { 
//                     background-color: #ccc; 
//                     cursor: not-allowed; 
//                 }

//                 /* --- Template Selector Styles --- */
//                 .template-selector-container { 
//                     width: 90vw;
//                     max-width: 1200px;
//                 }
//                 .template-grid { 
//                     display: grid; 
//                     grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); 
//                     gap: 20px; 
//                 }
//                 .template-card { 
//                     border: 2px solid transparent; 
//                     border-radius: 8px; 
//                     overflow: hidden; 
//                     cursor: pointer; 
//                     transition: all 0.2s; 
//                     box-shadow: 0 2px 8px rgba(0,0,0,0.05); 
//                 }
//                 .template-card:hover { 
//                     transform: translateY(-5px); 
//                     box-shadow: 0 4px 15px rgba(0,0,0,0.1); 
//                 }
//                 .template-card.selected { 
//                     border-color: #3498db; 
//                     box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); 
//                 }
//                 .template-thumbnail img { 
//                     width: 100%; 
//                     height: auto; 
//                     display: block; 
//                     background-color: #eee; 
//                 }
//                 .template-info { 
//                     padding: 15px; 
//                 }
//                 .template-info h4 { 
//                     margin: 0 0 8px 0; 
//                     font-size: 16px; 
//                 }
//                 .template-info p { 
//                     margin: 0; 
//                     font-size: 14px; 
//                     color: #666; 
//                 }
//                 .main-content.fixed-sidebar{
//                 margin-left:0px;
//                 }
//             `}</style>
//         </div>
//     );
// };

// export default PortfolioEdit;

import React, { useEffect, useState, useCallback } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import StudioEditor from "@grapesjs/studio-sdk/react";
import "@grapesjs/studio-sdk/style";
import { useParams, useNavigate } from 'react-router-dom';
import { FaSync, FaDownload, FaArrowLeft, FaMagic, FaFileAlt, FaSave, FaFileExport } from 'react-icons/fa';
import axios from "axios";
import { updateProjectData, setSelectedTemplateForStage, updateStageBasicInfo } from '../../../../redux/funnel.jsx';
import { templates } from './df_temp.jsx';
import addLandingPageComponents from './function.jsx';
import "./old.css";

// GrapesJS Plugins
import gjsPresetWebpage from "grapesjs-preset-webpage";
import gjsForms from "grapesjs-plugin-forms";
import gjsCountdown from "grapesjs-component-countdown";
import gjsTabs from "grapesjs-tabs";
import gjsCustomCode from "grapesjs-custom-code";
import gjsTooltip from "grapesjs-tooltip";
import gjsTyped from "grapesjs-typed";
import gjsNavbar from "grapesjs-navbar";
import gjsBlocksBasic from "grapesjs-blocks-basic";

//** Template Selector Component **//
const StageTemplateSelector = ({ stageType, selectedKey, onSelect }) => {
  const templateSet = {
    'welcome-page': templates.welcomeTemplates,
    'vsl-page': templates.vslTemplates,
    'thankyou-page': templates.thankyouTemplates,
    'whatsapp-page': templates.whatsappTemplates,
    'product-offer': templates.productOfferTemplates,
    'custom-page': templates.miscTemplates,
    'appointment-page': templates.appointmentTemplates,
    'payment-page': templates.paymentTemplates,
  }[stageType];

  if (!templateSet || Object.keys(templateSet).length === 0) {
    return (
      <div className="no-templates-message">
        <p>No templates available for this stage type.</p>
      </div>
    );
  }

  return (
    <div className="template-selector-container">
      <h3 className="template-selector-title">Select a Template</h3>
      <div className="template-grid">
        {Object.entries(templateSet).map(([key, template]) => (
          <div
            key={key}
            className={`template-card ${selectedKey === key ? 'selected' : ''}`}
            onClick={() => onSelect(key)}
          >
            <div className="template-thumbnail">
              <img
                src={template.thumbnail}
                alt={template.name}
                onError={(e) => {
                  e.target.onerror = null;
                  e.target.src = 'https://placehold.co/400x300/ccc/ffffff?text=No+Image';
                }}
              />
            </div>
            <div className="template-info">
              <h4>{template.name}</h4>
              <p>{template.description}</p>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

//** AI Generative Popup Component **//
const AIGenerativePopup = ({ onClose, onSubmit, isLoading }) => {
  const [description, setDescription] = useState('');

  const handleSubmit = () => {
    if (!description.trim()) {
      alert('Please provide a description for the content you want to generate.');
      return;
    }
    onSubmit({ description });
  };

  return (
    <div className="ai-popup-content">
      <h3>AI Content Generation</h3>
      <p>Describe the changes you want to make to the content:</p>
      <div className="description-section">
        <label>Describe what you want:</label>
        <textarea
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          placeholder="e.g., 'Make the headline more exciting and shorten the paragraph about benefits.'"
          rows={4}
        />
      </div>
      <div className="ai-popup-buttons">
        <button onClick={onClose} className="ai-cancel-btn" disabled={isLoading}>
          Cancel
        </button>
        <button
          onClick={handleSubmit}
          className="ai-submit-btn"
          disabled={isLoading || !description.trim()}
        >
          {isLoading ? 'Generating...' : 'Update Content'}
        </button>
      </div>
    </div>
  );
};

//** Enhanced addLandingPageComponents with Video and Custom Image in Basic Section **//
const addEnhancedLandingPageComponents = (editor) => {
  // Call the existing function first
  addLandingPageComponents(editor);

  // Remove the old image block if it exists
  const existingImageBlock = editor.Blocks.get('image');
  if (existingImageBlock) {
    editor.Blocks.remove('image');
  }

  // Add custom video component
  editor.DomComponents.addType('custom-video', {
    model: {
      defaults: {
        tagName: 'div',
        classes: ['custom-video-container'],
        droppable: false,
        resizable: {
          tl: 1, // top left
          tc: 0, // top center
          tr: 1, // top right
          cl: 1, // center left
          cr: 1, // center right
          bl: 1, // bottom left
          bc: 0, // bottom center
          br: 1, // bottom right
          minDim: 50,
          maxDim: 2000,
          step: 1,
          keyWidth: 'width',
          keyHeight: 'height',
          autoHeight: false,
          keepAutoWidth: false,
          keepAutoHeight: false
        },
        traits: [
          {
            type: 'checkbox',
            name: 'maintain_aspect',
            label: 'Maintain Aspect Ratio',
            value: true
          },
          {
            type: 'select',
            name: 'object_fit',
            label: 'Video Fit',
            options: [
              { value: 'cover', name: 'Cover (fill container)' },
              { value: 'contain', name: 'Contain (fit inside)' },
              { value: 'fill', name: 'Fill (stretch)' },
              { value: 'none', name: 'None (original size)' }
            ],
            default: 'cover'
          },
          {
            type: 'checkbox',
            name: 'controls',
            label: 'Show Controls'
          },
          {
            type: 'checkbox',
            name: 'autoplay',
            label: 'Autoplay'
          },
          {
            type: 'checkbox',
            name: 'loop',
            label: 'Loop Video'
          },
          {
            type: 'checkbox',
            name: 'muted',
            label: 'Muted'
          }
        ],
        attributes: {
          'data-video-src': '',
          'data-video-uploaded': 'false',
          'data-video-width': '',
          'data-video-height': '',
          'data-aspect-ratio': ''
        },
        style: {
          'min-width': '100px',
          'min-height': '100px',
          'display': 'inline-block',
          'position': 'relative'
        }
      },
      
      init() {
        this.on('change:attributes', this.handleAttrChange);
        this.on('change:traits', this.handleTraitChange);
        this.on('change:style', this.handleStyleChange);
        
        // Listen for resize events
        this.on('component:resize', this.handleResize);
      },
      
      handleAttrChange() {
        this.view && this.view.render();
      },

      handleTraitChange() {
        this.view && this.view.render();
      },

      handleStyleChange() {
        this.view && this.view.render();
      },

      handleResize() {
        const maintainAspect = this.getTrait('maintain_aspect')?.get('value');
        const aspectRatio = parseFloat(this.get('attributes')['data-aspect-ratio']);
        
        if (maintainAspect && aspectRatio) {
          const currentWidth = parseFloat(this.getStyle('width'));
          if (currentWidth) {
            const newHeight = currentWidth / aspectRatio;
            this.setStyle('height', `${newHeight}px`);
          }
        }
      }
    },
    
    view: {
      events: {
        'click .video-upload-btn': 'openVideoUpload',
        'click .custom-video-play-btn': 'handlePlayClick',
        'dblclick .video-upload-placeholder': 'openVideoUpload',
        'click video': 'handleVideoClick',
        'loadedmetadata video': 'handleVideoMetadata'
      },
      
      init() {
        this.listenTo(this.model, 'change', this.render);
      },
      
      handleVideoMetadata(e) {
        const video = e.target;
        const videoWidth = video.videoWidth;
        const videoHeight = video.videoHeight;
        const aspectRatio = videoWidth / videoHeight;
        
        // Store original dimensions and aspect ratio
        this.model.set({
          attributes: {
            ...this.model.get('attributes'),
            'data-video-width': videoWidth,
            'data-video-height': videoHeight,
            'data-aspect-ratio': aspectRatio
          }
        });
        
        // Set the component to original video size
        this.model.setStyle({
          'width': `${videoWidth}px`,
          'height': `${videoHeight}px`
        });
        
        // Enable resizable handles
        this.model.set('resizable', {
          tl: 1, tc: 0, tr: 1,
          cl: 1, cr: 1,
          bl: 1, bc: 0, br: 1,
          minDim: 50,
          maxDim: 2000,
          step: 1,
          keyWidth: 'width',
          keyHeight: 'height',
          autoHeight: false,
          keepAutoWidth: false,
          keepAutoHeight: false,
          onMove: (e, opts) => {
            const maintainAspect = this.model.getTrait('maintain_aspect')?.get('value');
            if (maintainAspect && aspectRatio) {
              const newWidth = opts.w;
              const newHeight = newWidth / aspectRatio;
              return { w: newWidth, h: newHeight };
            }
          }
        });
        
        this.render();
      },
      
      openVideoUpload() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'video/*';
        input.style.display = 'none';
        
        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            try {
              this.showLoadingState();
              
              const formData = new FormData();
              formData.append('assets', file);
              
              const response = await fetch('http://localhost:5000/api/assets', {
                method: 'POST',
                body: formData,
              });
              
              if (!response.ok) {
                throw new Error('Upload failed');
              }
              
              const result = await response.json();
              const uploadedVideo = result.data[0];
              
              this.model.set({
                attributes: {
                  ...this.model.get('attributes'),
                  'data-video-src': uploadedVideo.src,
                  'data-video-uploaded': 'true'
                }
              });
              
              this.render();
              
            } catch (error) {
              console.error('Video upload failed:', error);
              alert('Failed to upload video');
              this.render();
            }
          }
        };
        
        document.body.appendChild(input);
        input.click();
        document.body.removeChild(input);
      },

      showLoadingState() {
        const currentWidth = this.model.getStyle('width') || '400px';
        const currentHeight = this.model.getStyle('height') || '300px';
        
        this.el.innerHTML = `
          <div class="video-loading-state" style="
            width: ${currentWidth}; 
            height: ${currentHeight}; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            background: #f5f5f5;
            border: 2px dashed #ddd;
            border-radius: 8px;
            color: #666;
            box-sizing: border-box;
          ">
            <div style="
              width: 40px;
              height: 40px;
              border: 4px solid #ddd;
              border-top: 4px solid #3498db;
              border-radius: 50%;
              animation: spin 1s linear infinite;
              margin-bottom: 15px;
            "></div>
            <p style="margin: 0; font-size: 14px;">Uploading video...</p>
          </div>
          <style>
            @keyframes spin {
              0% { transform: rotate(0deg); }
              100% { transform: rotate(360deg); }
            }
          </style>
        `;
      },
      
      handlePlayClick(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const video = this.el.querySelector('video');
        const playBtn = this.el.querySelector('.custom-video-play-btn');
        const pauseBtn = this.el.querySelector('.custom-video-pause-btn');
        
        if (video) {
          if (video.paused) {
            video.play();
            if (playBtn) playBtn.style.display = 'none';
            if (pauseBtn) pauseBtn.style.display = 'flex';
          } else {
            video.pause();
            if (playBtn) playBtn.style.display = 'flex';
            if (pauseBtn) pauseBtn.style.display = 'none';
          }
        }
      },

      handleVideoClick(e) {
        e.preventDefault();
        e.stopPropagation();
        this.handlePlayClick(e);
      },
      
      render() {
        const videoSrc = this.model.get('attributes')['data-video-src'];
        const isUploaded = this.model.get('attributes')['data-video-uploaded'] === 'true';
        const showControls = this.model.getTrait('controls')?.get('value');
        const autoplay = this.model.getTrait('autoplay')?.get('value');
        const loop = this.model.getTrait('loop')?.get('value');
        const muted = this.model.getTrait('muted')?.get('value');
        const objectFit = this.model.getTrait('object_fit')?.get('value') || 'cover';
        
        // Get current dimensions from model styles
        const currentWidth = this.model.getStyle('width') || '100%';
        const currentHeight = this.model.getStyle('height') || '300px';
        
        if (isUploaded && videoSrc) {
          this.el.innerHTML = `
            <div class="custom-video-player" style="
              width: 100%;
              height: 100%;
              position: relative;
              background: #000;
              border-radius: 8px;
              overflow: hidden;
              cursor: pointer;
              box-shadow: 0 4px 12px rgba(0,0,0,0.15);
              box-sizing: border-box;
            ">
              <video 
                style="
                  width: 100%;
                  height: 100%;
                  object-fit: ${objectFit};
                  display: block;
                "
                preload="metadata"
                ${showControls ? 'controls' : ''}
                ${autoplay ? 'autoplay' : ''}
                ${loop ? 'loop' : ''}
                ${muted ? 'muted' : ''}
                onended="this.parentElement.querySelector('.custom-video-play-btn').style.display = 'flex'; this.parentElement.querySelector('.custom-video-pause-btn').style.display = 'none';"
                onplay="this.parentElement.querySelector('.custom-video-play-btn').style.display = 'none'; this.parentElement.querySelector('.custom-video-pause-btn').style.display = 'flex';"
                onpause="this.parentElement.querySelector('.custom-video-play-btn').style.display = 'flex'; this.parentElement.querySelector('.custom-video-pause-btn').style.display = 'none';"
              >
                <source src="${videoSrc}" type="video/mp4">
                Your browser does not support the video tag.
              </video>
              
              <!-- Play Button -->
              <div class="custom-video-play-btn" style="
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 80px;
                height: 80px;
                background: rgba(255, 255, 255, 0.95);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10;
              ">
                <svg width="36" height="36" viewBox="0 0 24 24" fill="none">
                  <path d="M8 5V19L19 12L8 5Z" fill="#333" stroke="#333" stroke-width="1"/>
                </svg>
              </div>

              <!-- Pause Button -->
              <div class="custom-video-pause-btn" style="
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 80px;
                height: 80px;
                background: rgba(255, 255, 255, 0.95);
                border-radius: 50%;
                display: none;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10;
              ">
                <svg width="36" height="36" viewBox="0 0 24 24" fill="none">
                  <rect x="6" y="4" width="4" height="16" fill="#333"/>
                  <rect x="14" y="4" width="4" height="16" fill="#333"/>
                </svg>
              </div>

              <!-- Video Info Overlay -->
              <div class="video-info-overlay" style="
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background: linear-gradient(transparent, rgba(0,0,0,0.7));
                color: white;
                padding: 20px 15px 15px;
                font-size: 14px;
                opacity: 0;
                transition: opacity 0.3s ease;
              ">
                <div style="font-weight: 500;">Custom Video Player</div>
                <div style="font-size: 12px; opacity: 0.8; margin-top: 2px;">Click to play/pause â€¢ Drag corners to resize</div>
              </div>
            </div>
          `;

          // Add hover effects
          const player = this.el.querySelector('.custom-video-player');
          const overlay = this.el.querySelector('.video-info-overlay');
          const playBtn = this.el.querySelector('.custom-video-play-btn');
          const pauseBtn = this.el.querySelector('.custom-video-pause-btn');

          if (player && overlay) {
            player.addEventListener('mouseenter', () => {
              overlay.style.opacity = '1';
              if (playBtn) playBtn.style.transform = 'translate(-50%, -50%) scale(1.1)';
              if (pauseBtn) pauseBtn.style.transform = 'translate(-50%, -50%) scale(1.1)';
            });
            
            player.addEventListener('mouseleave', () => {
              overlay.style.opacity = '0';
              if (playBtn) playBtn.style.transform = 'translate(-50%, -50%) scale(1)';
              if (pauseBtn) pauseBtn.style.transform = 'translate(-50%, -50%) scale(1)';
            });
          }

        } else {
          // Upload placeholder
          this.el.innerHTML = `
            <div class="video-upload-placeholder" style="
              width: 100%;
              height: 100%;
              min-height: 200px;
              border: 2px dashed #ccc; 
              display: flex; 
              flex-direction: column; 
              align-items: center; 
              justify-content: center; 
              background: linear-gradient(135deg, #f9f9f9 0%, #f5f5f5 100%);
              border-radius: 12px;
              cursor: pointer;
              transition: all 0.3s ease;
              position: relative;
              overflow: hidden;
              box-sizing: border-box;
            ">
              <div class="upload-icon-container" style="
                background: rgba(52, 152, 219, 0.1);
                border-radius: 50%;
                padding: 20px;
                margin-bottom: 15px;
                transition: all 0.3s ease;
              ">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" style="color: #3498db;">
                  <path d="M14 2H6C4.9 2 4 2.9 4 4V20C4 21.1 4.89 22 5.99 22H18C19.1 22 20 21.1 20 20V8L14 2Z" stroke="currentColor" stroke-width="1.5" fill="none"/>
                  <path d="M14 2V8H20" stroke="currentColor" stroke-width="1.5" fill="none"/>
                  <polygon points="10,12 14,16 18,12" fill="currentColor"/>
                  <line x1="14" y1="16" x2="14" y2="8" stroke="currentColor" stroke-width="2"/>
                </svg>
              </div>
              <div style="text-align: center; color: #666;">
                <h3 style="margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: #333;">Upload Video</h3>
                <p style="margin: 0 0 5px 0; font-size: 14px;">Video will appear in its original size</p>
                <p style="margin: 0; font-size: 12px; opacity: 0.7;">Drag corners to resize after upload</p>
              </div>
              <button class="video-upload-btn" style="
                margin-top: 20px;
                padding: 12px 24px;
                background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
                color: white;
                border: none;
                border-radius: 25px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 500;
                transition: all 0.3s ease;
                box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
              ">
                Choose Video File
              </button>
            </div>
          `;
          
          // Add hover effects for upload placeholder
          const placeholder = this.el.querySelector('.video-upload-placeholder');
          if (placeholder) {
            const iconContainer = placeholder.querySelector('.upload-icon-container');
            const uploadBtn = placeholder.querySelector('.video-upload-btn');
            
            placeholder.addEventListener('mouseenter', () => {
              placeholder.style.borderColor = '#3498db';
              placeholder.style.background = 'linear-gradient(135deg, #f0f8ff 0%, #e8f4fd 100%)';
              placeholder.style.transform = 'translateY(-2px)';
              placeholder.style.boxShadow = '0 8px 25px rgba(52, 152, 219, 0.15)';
              
              if (iconContainer) {
                iconContainer.style.background = 'rgba(52, 152, 219, 0.2)';
                iconContainer.style.transform = 'scale(1.1)';
              }
              
              if (uploadBtn) {
                uploadBtn.style.transform = 'translateY(-2px)';
                uploadBtn.style.boxShadow = '0 6px 20px rgba(52, 152, 219, 0.4)';
              }
            });
            
            placeholder.addEventListener('mouseleave', () => {
              placeholder.style.borderColor = '#ccc';
              placeholder.style.background = 'linear-gradient(135deg, #f9f9f9 0%, #f5f5f5 100%)';
              placeholder.style.transform = 'translateY(0)';
              placeholder.style.boxShadow = 'none';
              
              if (iconContainer) {
                iconContainer.style.background = 'rgba(52, 152, 219, 0.1)';
                iconContainer.style.transform = 'scale(1)';
              }
              
              if (uploadBtn) {
                uploadBtn.style.transform = 'translateY(0)';
                uploadBtn.style.boxShadow = '0 4px 15px rgba(52, 152, 219, 0.3)';
              }
            });
          }
        }
        
        return this;
      }
    }
  });

  // Add custom image component
  editor.DomComponents.addType('custom-image', {
    model: {
      defaults: {
        tagName: 'div',
        classes: ['custom-image-container'],
        droppable: false,
        resizable: {
          tl: 1, // top left
          tc: 0, // top center
          tr: 1, // top right
          cl: 1, // center left
          cr: 1, // center right
          bl: 1, // bottom left
          bc: 0, // bottom center
          br: 1, // bottom right
          minDim: 50,
          maxDim: 2000,
          step: 1,
          keyWidth: 'width',
          keyHeight: 'height',
          autoHeight: false,
          keepAutoWidth: false,
          keepAutoHeight: false
        },
        traits: [
          {
            type: 'checkbox',
            name: 'maintain_aspect',
            label: 'Maintain Aspect Ratio',
            value: true
          },
          {
            type: 'select',
            name: 'object_fit',
            label: 'Image Fit',
            options: [
              { value: 'cover', name: 'Cover (fill container)' },
              { value: 'contain', name: 'Contain (fit inside)' },
              { value: 'fill', name: 'Fill (stretch)' },
              { value: 'none', name: 'None (original size)' }
            ],
            default: 'cover'
          },
          {
            type: 'text',
            name: 'alt_text',
            label: 'Alt Text',
            placeholder: 'Image description'
          },
          {
            type: 'select',
            name: 'border_style',
            label: 'Border Style',
            options: [
              { value: 'none', name: 'None' },
              { value: 'solid', name: 'Solid' },
              { value: 'dashed', name: 'Dashed' },
              { value: 'dotted', name: 'Dotted' }
            ],
            default: 'none'
          },
          {
            type: 'slider',
            name: 'border_width',
            label: 'Border Width',
            min: 0,
            max: 10,
            step: 1,
            default: 0
          },
          {
            type: 'color',
            name: 'border_color',
            label: 'Border Color',
            default: '#000000'
          },
          {
            type: 'slider',
            name: 'border_radius',
            label: 'Border Radius',
            min: 0,
            max: 50,
            step: 1,
            default: 0
          }
        ],
        attributes: {
          'data-image-src': '',
          'data-image-uploaded': 'false',
          'data-image-width': '',
          'data-image-height': '',
          'data-aspect-ratio': ''
        },
        style: {
          'min-width': '100px',
          'min-height': '100px',
          'display': 'inline-block',
          'position': 'relative'
        }
      },
      
      init() {
        this.on('change:attributes', this.handleAttrChange);
        this.on('change:traits', this.handleTraitChange);
        this.on('change:style', this.handleStyleChange);
        
        // Listen for resize events
        this.on('component:resize', this.handleResize);
      },
      
      handleAttrChange() {
        this.view && this.view.render();
      },

      handleTraitChange() {
        this.view && this.view.render();
      },

      handleStyleChange() {
        this.view && this.view.render();
      },

      handleResize() {
        const maintainAspect = this.getTrait('maintain_aspect')?.get('value');
        const aspectRatio = parseFloat(this.get('attributes')['data-aspect-ratio']);
        
        if (maintainAspect && aspectRatio) {
          const currentWidth = parseFloat(this.getStyle('width'));
          if (currentWidth) {
            const newHeight = currentWidth / aspectRatio;
            this.setStyle('height', `${newHeight}px`);
          }
        }
      }
    },
    
    view: {
      events: {
        'click .image-upload-btn': 'openImageUpload',
        'dblclick .image-upload-placeholder': 'openImageUpload',
        'load img': 'handleImageLoad'
      },
      
      init() {
        this.listenTo(this.model, 'change', this.render);
      },
      
      handleImageLoad(e) {
        const img = e.target;
        const imageWidth = img.naturalWidth;
        const imageHeight = img.naturalHeight;
        const aspectRatio = imageWidth / imageHeight;
        
        // Store original dimensions and aspect ratio
        this.model.set({
          attributes: {
            ...this.model.get('attributes'),
            'data-image-width': imageWidth,
            'data-image-height': imageHeight,
            'data-aspect-ratio': aspectRatio
          }
        });
        
        // Set the component to original image size
        this.model.setStyle({
          'width': `${imageWidth}px`,
          'height': `${imageHeight}px`
        });
        
        // Enable resizable handles
        this.model.set('resizable', {
          tl: 1, tc: 0, tr: 1,
          cl: 1, cr: 1,
          bl: 1, bc: 0, br: 1,
          minDim: 50,
          maxDim: 2000,
          step: 1,
          keyWidth: 'width',
          keyHeight: 'height',
          autoHeight: false,
          keepAutoWidth: false,
          keepAutoHeight: false,
          onMove: (e, opts) => {
            const maintainAspect = this.model.getTrait('maintain_aspect')?.get('value');
            if (maintainAspect && aspectRatio) {
              const newWidth = opts.w;
              const newHeight = newWidth / aspectRatio;
              return { w: newWidth, h: newHeight };
            }
          }
        });
        
        this.render();
      },
      
      openImageUpload() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.style.display = 'none';
        
        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            try {
              this.showLoadingState();
              
              const formData = new FormData();
              formData.append('assets', file);
              
              const response = await fetch('http://localhost:5000/api/assets', {
                method: 'POST',
                body: formData,
              });
              
              if (!response.ok) {
                throw new Error('Upload failed');
              }
              
              const result = await response.json();
              const uploadedImage = result.data[0];
              
              this.model.set({
                attributes: {
                  ...this.model.get('attributes'),
                  'data-image-src': uploadedImage.src,
                  'data-image-uploaded': 'true'
                }
              });
              
              this.render();
              
            } catch (error) {
              console.error('Image upload failed:', error);
              alert('Failed to upload image');
              this.render();
            }
          }
        };
        
        document.body.appendChild(input);
        input.click();
        document.body.removeChild(input);
      },

      showLoadingState() {
        const currentWidth = this.model.getStyle('width') || '300px';
        const currentHeight = this.model.getStyle('height') || '200px';
        
        this.el.innerHTML = `
          <div class="image-loading-state" style="
            width: ${currentWidth}; 
            height: ${currentHeight}; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            background: #f5f5f5;
            border: 2px dashed #ddd;
            border-radius: 8px;
            color: #666;
            box-sizing: border-box;
          ">
            <div style="
              width: 40px;
              height: 40px;
              border: 4px solid #ddd;
              border-top: 4px solid #e74c3c;
              border-radius: 50%;
              animation: spin 1s linear infinite;
              margin-bottom: 15px;
            "></div>
            <p style="margin: 0; font-size: 14px;">Uploading image...</p>
          </div>
          <style>
            @keyframes spin {
              0% { transform: rotate(0deg); }
              100% { transform: rotate(360deg); }
            }
          </style>
        `;
      },
      
      render() {
        const imageSrc = this.model.get('attributes')['data-image-src'];
        const isUploaded = this.model.get('attributes')['data-image-uploaded'] === 'true';
        const objectFit = this.model.getTrait('object_fit')?.get('value') || 'cover';
        const altText = this.model.getTrait('alt_text')?.get('value') || 'Custom Image';
        const borderStyle = this.model.getTrait('border_style')?.get('value') || 'none';
        const borderWidth = this.model.getTrait('border_width')?.get('value') || 0;
        const borderColor = this.model.getTrait('border_color')?.get('value') || '#000000';
        const borderRadius = this.model.getTrait('border_radius')?.get('value') || 0;
        
        if (isUploaded && imageSrc) {
          this.el.innerHTML = `
            <div class="custom-image-display" style="
              width: 100%;
              height: 100%;
              position: relative;
              border-radius: ${borderRadius}px;
              overflow: hidden;
              box-shadow: 0 4px 12px rgba(0,0,0,0.15);
              box-sizing: border-box;
              border: ${borderWidth}px ${borderStyle} ${borderColor};
            ">
              <img 
                src="${imageSrc}"
                alt="${altText}"
                style="
                  width: 100%;
                  height: 100%;
                  object-fit: ${objectFit};
                  display: block;
                  border-radius: ${borderRadius}px;
                "
              />
              
              <!-- Image Info Overlay -->
              <div class="image-info-overlay" style="
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background: linear-gradient(transparent, rgba(0,0,0,0.7));
                color: white;
                padding: 20px 15px 15px;
                font-size: 14px;
                opacity: 0;
                transition: opacity 0.3s ease;
              ">
                <div style="font-weight: 500;">Custom Image</div>
                <div style="font-size: 12px; opacity: 0.8; margin-top: 2px;">Drag corners to resize â€¢ Double-click to change</div>
              </div>
            </div>
          `;

          // Add hover effects
          const display = this.el.querySelector('.custom-image-display');
          const overlay = this.el.querySelector('.image-info-overlay');

          if (display && overlay) {
            display.addEventListener('mouseenter', () => {
              overlay.style.opacity = '1';
              display.style.transform = 'scale(1.02)';
              display.style.transition = 'transform 0.3s ease';
            });
            
            display.addEventListener('mouseleave', () => {
              overlay.style.opacity = '0';
              display.style.transform = 'scale(1)';
            });
          }

        } else {
          // Upload placeholder
          this.el.innerHTML = `
            <div class="image-upload-placeholder" style="
              width: 100%;
              height: 100%;
              min-height: 150px;
              border: 2px dashed #ccc; 
              display: flex; 
              flex-direction: column; 
              align-items: center; 
              justify-content: center; 
              background: linear-gradient(135deg, #f9f9f9 0%, #f5f5f5 100%);
              border-radius: 12px;
              cursor: pointer;
              transition: all 0.3s ease;
              position: relative;
              overflow: hidden;
              box-sizing: border-box;
            ">
              <div class="upload-icon-container" style="
                background: rgba(231, 76, 60, 0.1);
                border-radius: 50%;
                padding: 20px;
                margin-bottom: 15px;
                transition: all 0.3s ease;
              ">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" style="color: #e74c3c;">
                  <rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke="currentColor" stroke-width="1.5" fill="none"/>
                  <circle cx="8.5" cy="8.5" r="1.5" fill="currentColor"/>
                  <path d="M21 15L16 10L5 21" stroke="currentColor" stroke-width="1.5" fill="none"/>
                </svg>
              </div>
              <div style="text-align: center; color: #666;">
                <h3 style="margin: 0 0 8px 0; font-size: 18px; font-weight: 600; color: #333;">Upload Image</h3>
                <p style="margin: 0 0 5px 0; font-size: 14px;">Image will appear in its original size</p>
                <p style="margin: 0; font-size: 12px; opacity: 0.7;">Drag corners to resize after upload</p>
              </div>
              <button class="image-upload-btn" style="
                margin-top: 20px;
                padding: 12px 24px;
                background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
                color: white;
                border: none;
                border-radius: 25px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 500;
                transition: all 0.3s ease;
                box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
              ">
                Choose Image File
              </button>
            </div>
          `;
          
          // Add hover effects for upload placeholder
          const placeholder = this.el.querySelector('.image-upload-placeholder');
          if (placeholder) {
            const iconContainer = placeholder.querySelector('.upload-icon-container');
            const uploadBtn = placeholder.querySelector('.image-upload-btn');
            
            placeholder.addEventListener('mouseenter', () => {
              placeholder.style.borderColor = '#e74c3c';
              placeholder.style.background = 'linear-gradient(135deg, #fdf2f2 0%, #fbeaea 100%)';
              placeholder.style.transform = 'translateY(-2px)';
              placeholder.style.boxShadow = '0 8px 25px rgba(231, 76, 60, 0.15)';
              
              if (iconContainer) {
                iconContainer.style.background = 'rgba(231, 76, 60, 0.2)';
                iconContainer.style.transform = 'scale(1.1)';
              }
              
              if (uploadBtn) {
                uploadBtn.style.transform = 'translateY(-2px)';
                uploadBtn.style.boxShadow = '0 6px 20px rgba(231, 76, 60, 0.4)';
              }
            });
            
            placeholder.addEventListener('mouseleave', () => {
              placeholder.style.borderColor = '#ccc';
              placeholder.style.background = 'linear-gradient(135deg, #f9f9f9 0%, #f5f5f5 100%)';
              placeholder.style.transform = 'translateY(0)';
              placeholder.style.boxShadow = 'none';
              
              if (iconContainer) {
                iconContainer.style.background = 'rgba(231, 76, 60, 0.1)';
                iconContainer.style.transform = 'scale(1)';
              }
              
              if (uploadBtn) {
                uploadBtn.style.transform = 'translateY(0)';
                uploadBtn.style.boxShadow = '0 4px 15px rgba(231, 76, 60, 0.3)';
              }
            });
          }
        }
        
        return this;
      }
    }
  });

  // Add video block to the Basic section with improved sizing
  editor.Blocks.add('custom-video', {
    label: 'Video',
    category: 'Basic',
    content: {
      type: 'custom-video'
    },
    media: `<svg viewBox="0 0 24 24" fill="currentColor" style="width: 18px; height: 18px; display: block; margin: 0 auto;">
      <rect x="2" y="3" width="20" height="14" rx="2" ry="2" stroke="currentColor" stroke-width="1.5" fill="none"/>
      <polygon points="10,8 16,12 10,16" fill="currentColor"/>
    </svg>`,
    attributes: { 
      class: 'fa fa-video-camera',
      title: 'Video Player'
    }
  });

  // Add custom image block to the Basic section with improved sizing
  editor.Blocks.add('custom-image', {
    label: 'Image',
    category: 'Basic',
    content: {
      type: 'custom-image'
    },
    media: `<svg viewBox="0 0 24 24" fill="currentColor" style="width: 18px; height: 18px; display: block; margin: 0 auto;">
      <rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke="currentColor" stroke-width="1.5" fill="none"/>
      <circle cx="8.5" cy="8.5" r="1.5" fill="currentColor"/>
      <path d="M21 15L16 10L5 21" stroke="currentColor" stroke-width="1.5" fill="none"/>
    </svg>`,
    attributes: { 
      class: 'fa fa-image',
      title: 'Custom Image'
    }
  });
};

//** Main Editor Component **//
const PortfolioEdit = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const { slug, stageId } = useParams();
  const { contentData, stages } = useSelector((state) => state.funnel);
  
  const [editorInstance, setEditorInstance] = useState(null);
  const [showTemplateSelector, setShowTemplateSelector] = useState(false);
  const [showAIPopup, setShowAIPopup] = useState(false);
  const [isAILoading, setIsAILoading] = useState(false);
  const [currentStage, setCurrentStage] = useState(null);
  const [forceRefreshKey, setForceRefreshKey] = useState(0);
  const [assets, setAssets] = useState([]);

  const uploadFiles = async files => {
    const fd = new FormData();
    files.forEach(f => fd.append('assets', f));
    const { data } = await axios.post('http://localhost:5000/api/assets', fd);
    return data;
  };

  // Fetch initial assets from the backend when the component mounts
  useEffect(() => {
    const fetchInitialAssets = async () => {
      try {
        const response = await fetch('http://localhost:5000/api/assets');
        if (!response.ok) {
          throw new Error(`Failed to fetch assets: ${response.statusText}`);
        }
        const result = await response.json();
        console.log("âœ… [Frontend] Initial assets loaded from backend:", result.data);
        setAssets(result.data || []);
      } catch (error) {
        console.error("âŒ [Frontend] Error fetching initial assets:", error);
        setAssets([]);
      }
    };
    fetchInitialAssets();
  }, []);

  const onEditorReady = useCallback((editor) => {
    window.editor = editor;
    setEditorInstance(editor);
    
    // Use enhanced component function instead of original
    addEnhancedLandingPageComponents(editor);

    const pagesEl = document.querySelector("#pages");
    if (pagesEl) {
      editor.Pages.__appendTo({ el: pagesEl });
    }

    setTimeout(() => {
      const pageToSelect = editor.Pages.get(stageId);
      if (pageToSelect) {
        editor.Pages.select(pageToSelect);
      } else if (editor.Pages.getAll().length > 0) {
        editor.Pages.select(editor.Pages.getAll()[0]);
      }
    }, 500);
  }, [stageId]);

  useEffect(() => {
    return () => {
      if (editorInstance) {
        editorInstance.destroy();
        setEditorInstance(null);
        delete window.editor;
      }
    };
  }, [editorInstance]);

  //** Core Data Handling Functions **//
  const generateInitialProject = useCallback(() => {
    console.log("[Frontend] Generating initial project structure for GrapesJS...");
    
    const orderedStages = stages.slice();
    const stageIndex = orderedStages.findIndex(stage => stage.id === stageId);
    
    if (stageIndex > 0) {
      const [selectedStage] = orderedStages.splice(stageIndex, 1);
      orderedStages.unshift(selectedStage);
    }

    const pages = orderedStages.map(stage => {
      const isCustom = stage.type === 'custom-page';
      const config = isCustom 
        ? contentData.customStagesConfig?.[stage.id] 
        : contentData.stagesConfig?.[stage.type];

      const templateSet = {
        'welcome-page': templates.welcomeTemplates,
        'vsl-page': templates.vslTemplates,
        'thankyou-page': templates.thankyouTemplates,
        'whatsapp-page': templates.whatsappTemplates,
        'product-offer': templates.productOfferTemplates,
        'custom-page': templates.miscTemplates,
        'appointment-page': templates.appointmentTemplates,
        'payment-page': templates.paymentTemplates,
      }[stage.type];

      const templateKey = config?.selectedTemplateKey;
      let template = templateKey && templateSet[templateKey] 
        ? templateSet[templateKey] 
        : Object.values(templateSet)[0];

      return {
        id: stage.id,
        name: stage.name,
        component: template?.html || `<h1>${stage.name}</h1><p>Template not loaded.</p>`,
        styles: template?.css || '',
        script: template?.js || '',
        basicInfo: config ? config.basicInfo : {}
      };
    });

    return { pages };
  }, [stages, contentData, stageId]);

  const applyDataToPage = (page, { html, css, js, basicInfo }) => {
    if (!editorInstance || !page) return;

    if (html !== undefined) {
      page.set('component', '');
      page.set('component', html);
    }
    if (css !== undefined) {
      editorInstance.Css.clear();
      editorInstance.Css.addRules(css);
    }
    if (js !== undefined) {
      page.set('script', js);
    }
    if (basicInfo) {
      page.set('basicInfo', basicInfo);
    }

    editorInstance.Pages.select(page);
    editorInstance.trigger('change:canvas');
  };

  const extractContentForAI = (editor) => {
    const content = [];
    const page = editor.Pages.getSelected();
    if (!page) return content;

    const walkComponents = (component) => {
      if (!component || !component.view || !component.view.el) return;

      if (component.is('text') && component.toHTML().trim().length > 0) {
        content.push({
          id: component.cid,
          type: 'text',
          content: component.toHTML()
        });
      } else if (component.is('image')) {
        content.push({
          id: component.cid,
          type: 'image',
          src: component.get('src')
        });
      }

      component.components().forEach(walkComponents);
    };

    walkComponents(page.getMainComponent());
    return content;
  };

  const applyAIUpdates = (editor, updatedData) => {
    if (!editor || !updatedData) return;

    const currentPage = editor.Pages.getSelected();
    if (!currentPage) return;

    updatedData.forEach(item => {
      const component = currentPage.getMainComponent().find(`#${item.id}`)[0];
      if (component) {
        if (item.type === 'text' && item.content !== undefined) {
          component.components(item.content);
        } else if (item.type === 'image' && item.src !== undefined) {
          component.set('src', item.src);
        }
      } else {
        console.warn(`[Frontend] AI Update: Component with ID ${item.id} not found.`);
      }
    });

    editor.trigger('change:canvas');
  };

  // **FULLY FUNCTIONAL** Asset Upload Handler
  const handleAssetUpload = async (files, onResponse) => {
    const formData = new FormData();
    for (let i = 0; i < files.length; i++) {
      formData.append('assets', files[i]);
    }

    console.log("ðŸš€ [Frontend] Uploading files to backend...", files);

    try {
      const response = await fetch('http://localhost:5000/api/assets', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        const errData = await response.json();
        throw new Error(errData.error || 'Upload failed');
      }

      const result = await response.json();
      console.log('âœ… [Frontend] Files uploaded successfully. Backend response:', result);

      onResponse(result.data);
      setAssets(prevAssets => [...result.data, ...prevAssets]);
    } catch (error) {
      console.error('âŒ [Frontend] Upload error:', error);
      alert(`Failed to upload files: ${error.message}`);
      onResponse([]);
    }
  };

  // **FULLY FUNCTIONAL** Save Button Handler
  const handleSave = async (saveType) => {
    if (!editorInstance) {
      alert("Editor is not ready.");
      return;
    }

    const editor = editorInstance;
    let url = '';
    let payload = {};

    const extractAssetsFromHtml = (html) => {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const images = Array.from(doc.querySelectorAll('img')).map(img => img.src);
      const videos = Array.from(doc.querySelectorAll('video source')).map(source => source.src);
      return [...new Set([...images, ...videos])].filter(url => url.startsWith('http'));
    };

    if (saveType === 'single') {
      const currentPage = editor.Pages.getSelected();
      if (!currentPage) {
        alert("No page is selected to save.");
        return;
      }

      const pageHtml = editor.getHtml();
      payload = {
        pageId: currentPage.id,
        name: currentPage.get('name'),
        html: pageHtml,
        css: editor.getCss(),
        js: currentPage.get('script'),
        assets: extractAssetsFromHtml(pageHtml),
        basicInfo: currentPage.get('basicInfo') || {},
      };
      url = 'http://localhost:5000/api/pages/save-single';
    } else {
      const allPagesData = editor.Pages.getAll().map(page => {
        const pageHtml = page.getMainComponent().toHTML();
        return {
          pageId: page.id,
          name: page.get('name'),
          html: pageHtml,
          js: page.get('script'),
          assets: extractAssetsFromHtml(pageHtml),
          basicInfo: page.get('basicInfo') || {},
        };
      });

      payload = {
        pages: allPagesData,
        globalCss: editor.getCss()
      };
      url = 'http://localhost:5000/api/pages/save-all';
    }

    console.log(`ðŸš€ [Frontend] Saving ${saveType} data. Sending to backend:`, payload);

    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        throw new Error(`Server responded with status: ${response.status}`);
      }

      const result = await response.json();
      console.log("âœ… [Frontend] Save successful. Backend response:", result);
      alert(result.message);

      dispatch(updateProjectData(saveType === 'single' 
        ? { pages: [payload], globalCss: editor.getCss() } 
        : payload
      ));
    } catch (error) {
      console.error('âŒ [Frontend] Save error:', error);
      alert(`Failed to save data: ${error.message}`);
    }
  };

  const handleDownloadProject = () => {
    if (!editorInstance) {
      alert("Editor is not ready.");
      return;
    }

    const editor = editorInstance;
    const currentPage = editor.Pages.getSelected();
    
    if (!currentPage) {
      alert("No page is selected to download.");
      return;
    }

    const pageName = currentPage.get('name') || `page-${currentPage.cid}`;
    const fullCode = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>${pageName}</title><style>${editor.getCss()}</style></head><body>${editor.getHtml()}<script>${currentPage.get('script') || ''}</script></body></html>`;

    const blob = new Blob([fullCode], { type: 'text/html' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `${pageName.toLowerCase().replace(/\s+/g, '-')}.html`;
    a.click();
    URL.revokeObjectURL(a.href);
  };

  // **FULLY FUNCTIONAL** AI Submit Handler
  const handleAISubmit = async ({ description }) => {
    if (!editorInstance) {
      alert("Editor not available.");
      return;
    }

    const page = editorInstance.Pages.getSelected();
    if (!page) {
      alert("Please select a page first.");
      return;
    }

    setIsAILoading(true);
    const contentToUpdate = extractContentForAI(editorInstance);

    if (contentToUpdate.length === 0) {
      alert("No text or image content found on this page to update.");
      setIsAILoading(false);
      return;
    }

    const requestBody = {
      description,
      contentToUpdate,
      pageInfo: {
        id: page.id,
        name: page.get('name')
      }
    };

    console.log("ðŸš€ [Frontend] Sending content to AI API:", requestBody);

    try {
      const response = await fetch('http://localhost:5000/api/ai/generate-content', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`Server responded with status: ${response.status}`);
      }

      const aiResponse = await response.json();
      console.log("âœ… [Frontend] Received AI response:", aiResponse);

      applyAIUpdates(editorInstance, aiResponse.updatedContent);
      alert("Content updated successfully by AI!");
    } catch (error) {
      console.error('âŒ [Frontend] AI Generation Error:', error);
      alert(`Failed to update content: ${error.message}`);
    } finally {
      setIsAILoading(false);
      setShowAIPopup(false);
    }
  };

  const handleTemplateSelect = (templateKey) => {
    if (!currentStage || !editorInstance) return;

    const templateSet = {
      'welcome-page': templates.welcomeTemplates,
      'vsl-page': templates.vslTemplates,
      'thankyou-page': templates.thankyouTemplates,
      'whatsapp-page': templates.whatsappTemplates,
      'product-offer': templates.productOfferTemplates,
      'custom-page': templates.miscTemplates,
      'appointment-page': templates.appointmentTemplates,
      'payment-page': templates.paymentTemplates,
    }[currentStage.type];

    const template = templateSet?.[templateKey];
    if (!template) {
      console.error('Template not found:', templateKey);
      return;
    }

    dispatch(setSelectedTemplateForStage({
      stageId: currentStage.id,
      templateKey,
      stageType: currentStage.type
    }));

    const page = editorInstance.Pages.get(currentStage.id);
    if (page) {
      applyDataToPage(page, {
        html: template.html,
        css: template.css,
        js: template.js,
        basicInfo: template.basicInfo || {}
      });
    }

    setShowTemplateSelector(false);
  };

  const openTemplateSelector = (stage) => {
    setCurrentStage(stage);
    setShowTemplateSelector(true);
  };

  const getSelectedTemplateKey = () => {
    if (!currentStage) return null;
    
    const config = currentStage.type === 'custom-page'
      ? contentData.customStagesConfig?.[currentStage.id]
      : contentData.stagesConfig?.[currentStage.type];
    
    return config?.selectedTemplateKey;
  };

  const forceTemplateRefresh = () => {
    if (window.confirm("Are you sure? This will reload all pages from their initial templates and discard unsaved changes.")) {
      setForceRefreshKey(prev => prev + 1);
    }
  };

  const editorKey = `funnel-editor-${slug}-${forceRefreshKey}`;

  return (
    <div className="portfolio-edit-container">
      {showTemplateSelector && currentStage && (
        <div className="modal-overlay">
          <div className="modal-content">
            <button
              className="modal-close-btn"
              onClick={() => setShowTemplateSelector(false)}
            >Ã—</button>
            <StageTemplateSelector
              stageType={currentStage.type}
              selectedKey={getSelectedTemplateKey()}
              onSelect={handleTemplateSelect}
            />
          </div>
        </div>
      )}

      {showAIPopup && (
        <div className="modal-overlay">
          <div className="modal-content ai-modal-content">
            <AIGenerativePopup
              isLoading={isAILoading}
              onClose={() => setShowAIPopup(false)}
              onSubmit={handleAISubmit}
            />
          </div>
        </div>
      )}

      <div className="action-buttons">
        <button onClick={() => handleSave('single')} className="action-button save-button">
          <FaSave />
          <span>Save Page</span>
        </button>
        <button onClick={() => handleSave('all')} className="action-button save-all-button">
          <FaFileExport />
          <span>Save All</span>
        </button>
        <button onClick={() => setShowAIPopup(true)} className="action-button ai-generate-button">
          <FaMagic />
          <span>AI Content</span>
        </button>
        <button onClick={forceTemplateRefresh} className="action-button refresh-button">
          <FaSync />
          <span>Refresh</span>
        </button>
        <button onClick={handleDownloadProject} className="action-button download-button">
          <FaDownload />
          <span>Download</span>
        </button>
        <button
          onClick={() => navigate(`/dashboard/Funnel_settings/${slug}`)}
          className="action-button back-button"
        >
          <FaArrowLeft />
          <span>Back</span>
        </button>
      </div>

      <div className="editor-main-area">
        <div id="pages" className="pages-container" />
        <StudioEditor
          key={editorKey}
          onEditor={onEditorReady}
          style={{ width: "100%", height: "100%" }}
          options={{
            storage: {
              type: "self",
              onSave: async ({ project }) =>
                console.log("[Frontend] Project auto-synced (GrapesJS internal).", project),
              onLoad: () => ({ project: generateInitialProject() }),
            },
            assetManager: {
              assets,
              upload: 'http://localhost:5000/api/assets',
              uploadName: 'assets',
              multiUpload: true,
              customUpload: async (files, onComplete, onError) => {
                try {
                  const uploaded = await uploadFiles(files);
                  onComplete(uploaded);
                  setAssets(prev => [...uploaded, ...prev]);
                } catch (err) {
                  console.error(err);
                  onError(err.message);
                }
              },
            },
            plugins: [
              gjsForms,
              gjsCountdown,
              gjsTabs,
              gjsCustomCode,
              gjsTooltip,
              gjsTyped,
              gjsNavbar,
              gjsBlocksBasic,
            ],
          }}
        />
      </div>

      <style jsx>{`
        /* --- Main Layout --- */
        .portfolio-edit-container {
          display: flex;
          height: 100vh;
          width: 100vw;
          position: relative;
          overflow: hidden;
          font-family: 'Segoe UI', Tahoma, sans-serif;
          background-color: #f0f2f5;
        }

        .editor-main-area {
          flex-grow: 1;
          position: relative;
          height: 100%;
        }

        .pages-container {
          position: absolute;
          top: 15px;
          left: 15px;
          z-index: 1000;
          background: rgba(30, 30, 30, 0.9);
          color: white;
          padding: 8px;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }

        /* --- Action Buttons --- */
        .action-buttons {
          position: fixed;
          bottom: 20px;
          right: 20px;
          z-index: 1001;
          display: flex;
          flex-direction: column;
          gap: 12px;
        }

        .action-button {
          padding: 12px 18px;
          border: none;
          border-radius: 8px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s ease;
          box-shadow: 0 2px 5px rgba(0,0,0,0.1);
          display: flex;
          align-items: center;
          gap: 10px;
          font-size: 14px;
        }

        .action-button:hover {
          transform: translateY(-3px);
          box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .action-button > svg {
          font-size: 1.1rem;
        }

        .save-button { background-color: #3498db; color: white; }
        .save-all-button { background-color: #16a085; color: white; }
        .ai-generate-button { background-color: #8e44ad; color: white; }
        .refresh-button { background-color: #f39c12; color: white; }
        .download-button { background-color: #27ae60; color: white; }
        .back-button { background-color: #c0392b; color: white; }

        /* --- Modal Styles --- */
        .modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.6);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 2000;
        }

        .modal-content {
          background: white;
          padding: 25px;
          border-radius: 10px;
          box-shadow: 0 5px 15px rgba(0,0,0,0.3);
          max-width: 90vw;
          max-height: 90vh;
          overflow-y: auto;
          position: relative;
        }

        .modal-close-btn {
          position: absolute;
          top: 10px;
          right: 15px;
          background: transparent;
          border: none;
          font-size: 24px;
          cursor: pointer;
          color: #888;
        }

        .ai-modal-content {
          max-width: 550px;
        }

        /* --- AI Popup Specific Styles --- */
        .ai-popup-content h3 {
          margin-top: 0;
          color: #333;
        }

        .ai-popup-content p {
          color: #555;
          margin-bottom: 20px;
        }

        .description-section {
          margin-top: 15px;
        }

        .description-section label {
          display: block;
          margin-bottom: 8px;
          font-weight: 500;
        }

        .description-section textarea {
          width: 100%;
          padding: 10px;
          border-radius: 5px;
          border: 1px solid #ccc;
          resize: vertical;
          box-sizing: border-box;
        }

        .ai-popup-buttons {
          display: flex;
          justify-content: flex-end;
          gap: 10px;
          margin-top: 25px;
        }

        .ai-popup-buttons button {
          padding: 10px 20px;
          border-radius: 5px;
          border: none;
          font-weight: 500;
          cursor: pointer;
        }

        .ai-cancel-btn {
          background-color: #eee;
        }

        .ai-submit-btn {
          background-color: #8e44ad;
          color: white;
        }

        .ai-submit-btn:disabled {
          background-color: #ccc;
          cursor: not-allowed;
        }

        /* --- Template Selector Styles --- */
        .template-selector-container {
          width: 90vw;
          max-width: 1200px;
        }

        .template-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
          gap: 20px;
        }

        .template-card {
          border: 2px solid transparent;
          border-radius: 8px;
          overflow: hidden;
          cursor: pointer;
          transition: all 0.2s;
          box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .template-card:hover {
          transform: translateY(-5px);
          box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .template-card.selected {
          border-color: #3498db;
          box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }

        .template-thumbnail img {
          width: 100%;
          height: auto;
          display: block;
          background-color: #eee;
        }

        .template-info {
          padding: 15px;
        }

        .template-info h4 {
          margin: 0 0 8px 0;
          font-size: 16px;
        }

        .template-info p {
          margin: 0;
          font-size: 14px;
          color: #666;
        }

        .main-content.fixed-sidebar {
          margin-left:0px;
        }

        /* --- Custom Video Component Styles --- */
        .custom-video-container {
          position: relative;
          display: inline-block;
        }

        .custom-video-play-btn:hover,
        .custom-video-pause-btn:hover {
          background: rgba(255, 255, 255, 1) !important;
          transform: translate(-50%, -50%) scale(1.15) !important;
          box-shadow: 0 6px 25px rgba(0,0,0,0.4) !important;
        }

        .custom-video-player:hover .video-info-overlay {
          opacity: 1 !important;
        }

        /* --- Custom Image Component Styles --- */
        .custom-image-container {
          position: relative;
          display: inline-block;
        }

        .custom-image-display:hover .image-info-overlay {
          opacity: 1 !important;
        }
      `}</style>
    </div>
  );
};

export default PortfolioEdit;